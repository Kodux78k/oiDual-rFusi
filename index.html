<html lang="pt-BR"><head>
  <meta charset="utf-8">
  <title>DUAL // FUSION OS — V7 (Final Fluid)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#05070a">
  <link rel="apple-touch-icon" href="./icon-192.png">

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200;400;600;900&amp;family=JetBrains+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>

  <style>
    :root{
      --bg-deep:#030406; --glass-surface:rgba(18,18,22,0.65); --glass-border:rgba(255,255,255,0.06);
      --neon-cyan:#00f2ff; --neon-purple:#bd00ff; --neon-gold:#ffd700; --neon-danger:#ff2a6d; --neon-success:#00ff9d;
      --font-ui:'Montserrat',sans-serif; --font-code:'JetBrains Mono',monospace;
      --ease-overshoot: cubic-bezier(0.34, 1.3, 0.64, 1);
      --ease-smooth: cubic-bezier(0.23, 1, 0.32, 1);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;outline:none;user-select:none}
    .activation-pre, .cyber-input, input, textarea, .toaster, .response-block p { user-select:text !important; -webkit-user-select:text !important; }

    body{margin:0;padding:0;min-height:100vh;background-color:var(--bg-deep);color:#fff;
      font-family:var(--font-ui);overflow:hidden;
      background-image:linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size:52px 52px; /* Ajuste sutil para evitar cortes visuais nas bordas */
      background-position: center;
    }

    /* Ambient Light */
    .ambient-light{position:fixed;inset:0;z-index:0;pointer-events:none}
    .blob{position:absolute;border-radius:50%;filter:blur(100px);opacity:0.14;animation:float 25s infinite alternate ease-in-out}
    .blob-1{width:60vw;height:60vw;background:var(--neon-cyan);top:-20%;left:-20%}
    .blob-2{width:50vw;height:50vw;background:var(--neon-purple);bottom:-20%;right:-20%;animation-delay:-5s}
    @keyframes float{0%{transform:translate(0,0)}100%{transform:translate(40px,60px)}}

    /* --- CINEMATIC SNAP ZONE --- */
    #snap-zone {
        position: fixed; top: 0; left: 0; right: 0; height: 80px;
        background: linear-gradient(to bottom, rgba(0, 242, 255, 0.25), transparent);
        opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 9000;
        box-shadow: 0 0 40px rgba(0, 242, 255, 0.1);
    }
    #snap-zone.active { opacity: 1; }

    /* Container Central */
    .container{
      position: absolute; inset:0; pointer-events:none;
      display:flex; align-items:center; justify-content:center; perspective:1200px; z-index:10;
    }

    /* O Card Principal */
    .fusion-card{
      pointer-events:auto;
      width:100%; max-width:440px;
      /* Max height limitation allows scrolling if content expands too much */
      max-height: 85vh; overflow-y: auto; overflow-x: hidden;
      background:var(--glass-surface); backdrop-filter:blur(30px); -webkit-backdrop-filter:blur(30px);
      border:1px solid var(--glass-border); border-radius:36px; padding:30px 25px;
      box-shadow:0 40px 100px rgba(0,0,0,0.8);
      position:relative; opacity:0; transform:translateY(50px) scale(0.96);
      display:flex; flex-direction:column; gap:8px;
      transition: width 0.5s var(--ease-smooth), height 0.5s var(--ease-smooth), border-radius 0.5s var(--ease-smooth), opacity 0.4s, left 0.4s var(--ease-smooth), top 0.4s var(--ease-smooth), box-shadow 0.4s;
      will-change: transform, width, height, border-radius, left, top;
      
      /* Permite scroll vertical (pan-y) mas bloqueia horizontal e zoom */
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      
      scrollbar-width: none; /* Hide scrollbar Firefox */
    }
    .fusion-card::-webkit-scrollbar { display: none; } /* Hide scrollbar Chrome/Safari */
    .fusion-card.active{opacity:1;transform:translateY(0) scale(1);}

    /* Estado CLOSED */
    .fusion-card.closed{width:260px; padding:14px 16px; border-radius:22px;} 
    .fusion-card.closed .card-body{display:none}

    /* ESTADO: ORB */
    .fusion-card.orb {
      position: fixed !important;
      width: 68px !important; height: 68px !important;
      padding: 0 !important; border-radius: 50% !important;
      align-items: center; justify-content: center;
      box-shadow: 0 15px 40px rgba(0,0,0,0.6), 0 0 20px rgba(0,242,255,0.2);
      z-index: 9999;
      cursor: grab;
      touch-action: none; /* No orb, bloqueia tudo para arrastar livremente */
      overflow: visible; 
    }
    .fusion-card.orb:active { cursor: grabbing; transform: scale(0.95); }
    .fusion-card.orb .text-block, .fusion-card.orb .clock-widget, .fusion-card.orb .card-body, .fusion-card.orb .small-preview { display: none !important; }
    .fusion-card.orb .card-header { margin: 0; width: 100%; height: 100%; justify-content: center; padding:0; }
    .fusion-card.orb .avatar-slot { width: 54px; height: 54px; border-radius: 50%; margin:0; opacity: 1; pointer-events: none; }
    
    /* Orb Quick Menu Trigger */
    .orb-menu-trigger {
        position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%);
        width: 24px; height: 24px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2);
        border-radius: 50%; display: none; align-items: center; justify-content: center; cursor: pointer;
        color: #fff; font-size: 12px; pointer-events: auto; backdrop-filter: blur(4px);
    }
    .fusion-card.orb:hover .orb-menu-trigger { display: flex; }

    /* ESTADO: HUD */
    .fusion-card.hud {
      position: fixed !important; top: 0 !important; left: 50% !important;
      transform: translateX(-50%) !important; 
      width: 96% !important; max-width: 600px !important; height: 64px !important;
      padding: 0 16px !important; border-radius: 0 0 24px 24px !important;
      flex-direction: row; align-items: center; justify-content: space-between;
      box-shadow: 0 10px 40px rgba(0,0,0,0.7); z-index: 9999;
      overflow: visible;
      border-top: none;
      touch-action: none; /* Bloqueia scroll para gestos de puxar */
    }
    .fusion-card.hud .card-body, .fusion-card.hud .small-preview { display: none !important; }
    .fusion-card.hud .card-header { margin: 0; width: 100%; justify-content: space-between; }
    .fusion-card.hud .avatar-slot { width: 40px; height: 40px; }
    .fusion-card.hud .brand-dual { font-size: 1.2rem; margin:0; }
    .fusion-card.hud .greeting-row { display:none; } 
    .fusion-card.hud .text-block { flex: unset; }
    
    /* Helper de Arrastar no HUD */
    .drag-handle {
        width: 60px; height: 5px;
        background: rgba(255,255,255,0.15);
        border-radius: 10px;
        position: absolute; bottom: 8px; left: 50%;
        transform: translateX(-50%);
        display: none; cursor: grab; pointer-events: none; 
        transition: background 0.3s;
    }
    .fusion-card.hud:active .drag-handle { background: var(--neon-cyan); width: 70px; }
    .fusion-card.hud .drag-handle { display: block; }
    
    /* HUD Menu Btn */
    .hud-menu-btn { display: none; background: transparent; border: none; color: rgba(255,255,255,0.6); cursor: pointer; }
    .fusion-card.hud .hud-menu-btn { display: block; }
    .fusion-card.hud .clock-widget { display: none; } 

    /* Internals */
    .card-header{
        display:flex;align-items:center;gap:15px;margin-bottom:18px; width:100%; cursor: pointer;
        /* Header é área de arraste, então bloqueamos pan-y nativo aqui */
        touch-action: none; 
    }
    .avatar-slot{width:64px;height:64px;border-radius:18px;overflow:hidden;opacity:0;transition:opacity 0.35s}
    .avatar-slot.shown{opacity:1}

    .text-block{flex:1;display:flex;flex-direction:column;justify-content:center}
    .greeting-row{font-size:1.5rem;line-height:1;display:flex;align-items:baseline;gap:6px;flex-wrap:wrap}
    .txt-thin{font-weight:200;color:rgba(255,255,255,0.7)}
    .txt-heavy{font-weight:600;color:#fff}

    .brand-dual{font-size:2.2rem;font-weight:900;line-height:0.95;text-transform:uppercase;letter-spacing:-2px;margin-top:4px;
      background:linear-gradient(-45deg,#fff,var(--neon-cyan),var(--neon-purple),#fff);background-size:300%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:gradientFlow 4s ease infinite;
    }
    @keyframes gradientFlow{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}

    .clock-widget{text-align:right}
    .time-display{font-family:var(--font-code);font-size:1rem;color:rgba(255,255,255,0.5);font-weight:700}
    .status-led{font-size:0.6rem;color:var(--neon-cyan);text-transform:uppercase;letter-spacing:1px;margin-top:4px;display:block}

    /* Small Preview */
    .small-preview{display:none;align-items:center;gap:10px;margin-top:8px;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-family:var(--font-code);font-size:0.86rem;color:rgba(255,255,255,0.9);cursor:pointer;}
    .small-preview .mini-avatar{width:30px;height:30px;border-radius:6px;flex-shrink:0;overflow:hidden;display:inline-flex;align-items:center;justify-content:center}
    .small-preview .small-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:calc(100% - 110px)}
    .small-preview .ident-badge{margin-left:auto;font-weight:700;font-size:0.78rem;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);color:rgba(255,255,255,0.9);border:1px solid rgba(255,255,255,0.02)}
    .fusion-card.closed:not(.orb):not(.hud) .small-preview{display:flex}

    .card-body{display:flex;flex-direction:column;gap:12px}
    .stagger-item{opacity:0;transform:translateY(15px);transition:opacity 0.4s ease, transform 0.4s var(--ease-overshoot)}
    .content-visible .stagger-item{opacity:1;transform:translateY(0)}
    .content-visible .stagger-item:nth-child(1){transition-delay:0.1s}
    .content-visible .stagger-item:nth-child(2){transition-delay:0.18s}
    .content-visible .stagger-item:nth-child(3){transition-delay:0.25s}
    .content-visible .stagger-item:nth-child(4){transition-delay:0.30s}

    .cyber-input{width:100%;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:16px 50px 16px 18px;color:#fff;font-family:var(--font-code);font-size:0.9rem}

    /* COLLAPSIBLE SECTIONS */
    .activation-wrap{display:flex;flex-direction:column;gap:8px}
    .activation-card{background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;overflow:hidden;transition:all 320ms var(--ease-smooth)}
    .activation-pre{font-family:var(--font-code);white-space:pre-wrap;margin:0;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;border:1px dashed rgba(255,255,255,0.03);color:#fff;font-size:0.75rem}
    
    .activation-hidden{max-height:0;opacity:0;padding:0 12px;pointer-events:none; margin-top:0;}
    .activation-open{max-height:500px;opacity:1;padding:12px; margin-top:4px;}

    .activation-toggle {
        display: flex; align-items: center; justify-content: space-between;
        padding: 8px 4px; cursor: pointer; opacity: 0.9; transition: 0.2s;
    }
    .activation-toggle:hover { opacity: 1; }

    .trigger-btn{width:100%;padding:12px;border:1px dashed rgba(255,255,255,0.1);border-radius:12px;background:rgba(255,255,255,0.02);color:rgba(255,255,255,0.5);font-size:0.75rem;letter-spacing:2px;text-transform:uppercase;cursor:pointer;display:flex;justify-content:center;align-items:center;gap:8px;transition:0.2s}
    .trigger-btn:hover{background:rgba(255,255,255,0.04);color:#fff;border-color:rgba(255,255,255,0.3)}
    
    .mode-btn { background: rgba(0,242,255,0.05); border-color: rgba(0,242,255,0.2); color: var(--neon-cyan); }
    .mode-btn:hover { background: rgba(0,242,255,0.15); box-shadow: 0 0 15px rgba(0,242,255,0.1); }
    .mode-btn.active-mode { background: var(--neon-cyan); color: #000; box-shadow: 0 0 20px rgba(0,242,255,0.4); border-color:transparent; }

    .stats-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-top:10px}
    .stat-box{background:rgba(255,255,255,0.03);border-radius:12px;padding:10px;text-align:center}
    .stat-lbl{font-size:0.55rem;text-transform:uppercase;color:rgba(255,255,255,0.4);display:block;margin-bottom:4px}
    .stat-val{font-family:var(--font-code);font-size:0.9rem;font-weight:700;color:var(--neon-cyan)}

    .progress-container{background:rgba(0,0,0,0.2);padding:12px;border-radius:12px}
    .bar-track{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin:8px 0}
    .bar-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--neon-cyan),var(--neon-purple));box-shadow:0 0 10px var(--neon-cyan);transition:width 1.2s ease-out}
    .bar-meta{display:flex;justify-content:space-between;font-size:0.6rem;color:rgba(255,255,255,0.4);font-family:var(--font-code)}

    .toaster-wrap{position:fixed;right:20px;bottom:20px;z-index:99999;display:flex;flex-direction:column;gap:8px;pointer-events:none}
    .toaster{pointer-events:auto;background:linear-gradient(180deg,#0b1220,#071018);border:1px solid rgba(255,255,255,0.06);padding:10px 14px;border-radius:10px;box-shadow:0 18px 40px rgba(0,0,0,0.6);font-family:var(--font-ui);font-size:0.95rem;opacity:0;transform:translateY(8px);transition:all 260ms var(--ease-smooth)}
    .toaster.show{opacity:1;transform:translateY(0)}
    .toaster.error{border-color:var(--neon-danger);color:var(--neon-danger)}
    .toaster.success{border-color:var(--neon-success);color:var(--neon-success)}

    /* Keys Modal styles */
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.65);display:none;align-items:center;justify-content:center;z-index:99998;backdrop-filter:blur(8px)}
    .keys-card{width:90%;max-width:760px;background:linear-gradient(180deg,#071018,#0b1220);border:1px solid rgba(255,255,255,0.08);padding:20px;border-radius:16px;color:#fff;box-shadow:0 20px 50px rgba(0,0,0,0.8);max-height:90vh;display:flex;flex-direction:column}
    .keys-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid rgba(255,255,255,0.05)}
    .key-list{flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:8px;padding-right:6px;min-height:100px}
    .key-item{display:flex;align-items:center;gap:8px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02)}
    .key-item.active-item{background:rgba(0, 242, 255, 0.05);border-color:rgba(0, 242, 255, 0.2)}
    .key-item .meta{flex:1}
    .small-btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);padding:6px 10px;border-radius:8px;color:#fff;cursor:pointer;font-size:0.75rem;text-transform:uppercase;font-weight:600;transition:0.2s}
    .small-btn:hover{background:rgba(255,255,255,0.08);border-color:rgba(255,255,255,0.2)}
    .small-btn.active-btn{background:var(--neon-success);color:#000;border:none}
    .danger{color:var(--neon-danger);border-color:rgba(255,42,109,0.3)}
    .danger:hover{background:rgba(255,42,109,0.1)}

    .form-section{margin-top:15px;padding-top:15px;border-top:1px solid rgba(255,255,255,0.05)}
    .form-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
    .form-row{display:flex;gap:8px;}
    .form-row input, .form-grid input{width:100%;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:#030406;color:#fff;font-family:var(--font-code);font-size:0.85rem}
    .form-row input:focus, .form-grid input:focus{border-color:var(--neon-cyan)}

    /* Vault Modal */
    #vaultModal .keys-card{max-width:400px;text-align:center}
    .vault-icon{width:50px;height:50px;margin:0 auto 15px;color:var(--neon-purple);background:rgba(189,0,255,0.1);border-radius:50%;display:flex;align-items:center;justify-content:center}

    /* --- CHAT STYLES --- */
    #particles-js{position:absolute;inset:0;z-index:12; pointer-events:none; mix-blend-mode: lighten;}
    .svg-container{position:absolute;top:35%;left:50%;transform:translate(-50%,-50%);
                   width:160px;height:160px;z-index:-1; pointer-events: none; }
    .svg-container object{width:100%;height:100%;}

    .top-info {
      position: fixed; top: 28px; left:50%;transform:translate(-50%,-50%); z-index: 3;
      background: rgba(0,0,0,0.35); padding: 8px 12px; border-radius: 12px; font-size: 0.69em;
      backdrop-filter: blur(6px);
      pointer-events: none; 
    }

    .response-container{
      position:fixed; left:20px; right:20px; bottom:160px;
      padding:12px;background:rgba(0,0,0,0.4);backdrop-filter:blur(10px);
      border-radius:20px; max-height:calc(100vh - 220px); overflow-y:auto; -webkit-overflow-scrolling:touch; z-index:1;
    }
    .page{display:none; opacity:0; transition:opacity 0.8s ease-in-out}
    .page.active{display:block; opacity:1}
    .page.initial{text-align:center;font-size:1.1em}
    .response-controls{display:flex;justify-content:space-between;align-items:center;margin-top:15px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.2)}
    .control-buttons{display:flex;gap:10px;align-items:center}
    .control-btn{background:rgba(255,255,255,0.05);padding:6px;border-radius:6px;cursor:pointer;transition:background 0.4s;display:flex;gap:6px;border:none;outline:none}
    .control-btn:hover{background:rgba(255,255,255,0.12)}
    .control-btn svg{stroke:rgba(255,255,255,0.5);fill:none}
    
    /* Toggle Button Styles Updated */
    .toggle-button svg{color:#fff;stroke:rgba(255,255,255,0.3);fill:none; transition: all 0.3s;}
    .toggle-button.active svg{stroke:var(--neon-success); filter: drop-shadow(0 0 5px var(--neon-success));}
    .toggle-button.error svg{stroke:var(--neon-danger); filter: drop-shadow(0 0 5px var(--neon-danger));}
    
    .pagination{display:flex;align-items:center;gap:10px}
    .pagination button{background:none;border:none;font-size:1.2em;color:#6fe4fb;cursor:pointer;transition:transform 0.4s}
    .pagination button:hover{transform:scale(1.2)}

    .response-block{
      margin:1rem 0;padding:1.2rem;border-radius:12px;
      animation:fadeIn 1.8s ease forwards; transition:box-shadow 0.4s,transform 0.4s;
      line-height:1.5;position:relative;cursor:pointer;overflow:hidden;animation:pulse 6s infinite ease-in-out;
      background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(0,0,0,0.25));
      border: 1px solid rgba(255,255,255,0.03);
    }
    .response-block h3{margin-bottom:12px}
    .response-block:hover{box-shadow:0 0 15px rgba(0,255,255,0.12)}
    .response-block .meta { position:absolute; top:8px; right:8px; display:flex; gap:6px; }
    .crystal-btn {
      background: rgba(0,0,0,0.25); border-radius:6px; padding:6px; cursor:pointer; border:none; color:var(--neon-cyan);
    }
    .response-block.clicked{animation:clickPulse 0.8s ease-out}
    .response-block.expanded{transform:scale(1.03); background:rgba(0,0,0,0.6); z-index:2}
    .intro{background:linear-gradient(135deg,rgba(0,255,255,0.08),rgba(0,100,100,0.04));border-left:4px solid #0ff}
    .middle{background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(50,50,50,0.06));border-left:4px solid rgba(255,255,255,0.2)}
    .ending{background:linear-gradient(135deg,rgba(255,0,255,0.06),rgba(100,0,100,0.04));border-left:4px solid #f0f}
    .footer-text{margin-top:12px;font-size:0.8em;text-align:center;font-style:italic}

    .input-container{position:fixed;left:20px;right:20px;bottom:90px;display:flex;gap:10px;z-index:2;max-width:calc(100% - 40px)}
    .input-container input{flex:1;padding:10px;border:none;border-radius:20px;background:rgba(255,255,255,0.1);color:inherit;outline:none;font-size:16px;transition:background 0.4s}
    .input-container input:focus{background:rgba(255,255,255,0.2)}
    .input-container button{width:60px;height:60px;border:none;border-radius:50%;background:linear-gradient(45deg,#111,#5e5c5e);color:#fff;font-size:1.5em;cursor:pointer;display:flex;justify-content:center;align-items:center;animation:pulse 2s infinite ease-in-out;transition:transform 0.4s}
    .input-container button:hover{transform:scale(1.1)}

    /* Generic Modal / Panel */
    .modal, .panel { position: fixed; inset: 0; display: none; z-index: 9998; justify-content:center; align-items:center; }
    .modal.active, .panel.active { display:flex }
    .box {
      background:#1a1a1a;padding:20px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);
      width:90%;max-width:520px;box-shadow:0 8px 40px rgba(0,0,0,0.6); color:#fff;
    }
    .box h3{color:var(--neon-cyan);margin-bottom:8px}
    .row{display:flex;gap:10px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    .input-group label{font-size:0.85em;color:#aaa;margin-left:4px}
    .input-group input[type="text"], .input-group input[type="password"], .input-group input[type="file"]{
      width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(0,0,0,0.5);color:#fff;outline:none;
    }
    .settings-actions{display:flex;gap:10px;margin-top:12px}
    .btn{padding:10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .btn-prim{background:var(--neon-cyan);color:#000}
    .btn-sec{background:rgba(255,255,255,0.08);color:#fff}
    .small {font-size:0.85em;color:#bbb}
    .crystal-list { max-height:300px; overflow:auto; display:flex; flex-direction:column; gap:8px }
    .crystal-item { background: rgba(255,255,255,0.02); padding:8px; border-radius:8px; display:flex; justify-content:space-between; gap:8px; align-items:flex-start }
    .crystal-item .actions { display:flex; gap:6px }
    
    .panel-divider { height: 1px; background: rgba(255,255,255,0.1); margin: 15px 0; width: 100%; }
    .section-title { font-size: 0.8rem; text-transform: uppercase; color: var(--neon-cyan); letter-spacing: 1px; margin-bottom: 8px; font-weight: 700; }

    @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
    @keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
    @keyframes clickPulse{0%,100%{opacity:1}50%{opacity:0.8}}

    /* Mantra Footer */
    #mantra-toggle {
      position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); z-index: 1;
      background: rgba(15, 15, 15, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.06);
      padding: 10px 24px; border-radius: 100px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6); transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1); min-width: 280px;
    }
    #mantra-toggle:hover { background: rgba(25, 25, 25, 0.9); border-color: rgba(255,255,255,0.15); transform: translateX(-50%) translateY(-2px); }
    #mantra-text { font-style: italic; color: #777; font-size: 0.85rem; white-space: nowrap; transition: all 0.4s ease; }
    #mantra-toggle.collapsed { background: transparent; border-color: rgba(255, 215, 0, 0.3); box-shadow: 0 0 20px rgba(255, 215, 0, 0.05); padding: 10px 40px; }
    #mantra-toggle.collapsed #mantra-text { font-style: normal; font-weight: 600; letter-spacing: 3px; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }
    .fade-out { opacity: 0; transform: translateY(5px); }
    .fade-in { opacity: 1; transform: translateY(0); }
    body.zen-mode .response-container, body.zen-mode .input-container, body.zen-mode .top-info, body.zen-mode .svg-container { opacity: 0; pointer-events: none; filter: blur(12px); transition: all 0.6s ease; }

    @media (max-width:500px){ .form-grid{grid-template-columns:1fr} .keys-card{padding:15px} .key-item{flex-direction:column;align-items:flex-start} .key-item .actions{width:100%;display:flex;justify-content:flex-end;margin-top:8px} .box{max-width:92%} .svg-container{width:120px;height:120px} }
  </style>
<style>
        :root {
          --z-base: 0;
          --z-content: 100;
          --z-widget: 500;
          --z-overlay: 1000;
          --z-system: 5000;
        }
      </style><style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, #121926, #050811 60%, #000000 100%);
      --text: #e4ecff;
      --accent: #00f5ff;
      --accent-soft: rgba(0, 245, 255, .18);
      --accent-pink: #ff4bff;
      --danger: #ff4b6b;
      --radius-card: 18px;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 40px rgba(0,0,0,.65);
      --fast: .25s;
      --med: .6s;
      --slow: 1.4s;
    }

    * { box-sizing:border-box; margin:0; padding:0; }

    html, body {
      width:100%;
      height:100%;
      margin:0;
      padding:0 16px 96px;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .dual-chat-module {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(69px + env(safe-area-inset-bottom));
      width: min(520px, calc(100% - 32px));
      max-width: 520px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index: 1200;
      transition: transform .22s ease, opacity .18s ease;
      box-sizing:border-box;
    }

    .dual-chat-module.collapsed {
      transform: translateX(-50%) translateY(6px);
    }

    .dual-chat-title { font-size:.9rem; letter-spacing:.12em; text-transform:uppercase; opacity:.75; margin-bottom:2px; }
    .dual-chat-subtitle { font-size:.8rem; opacity:.8; margin-bottom:4px; }

    .response-container {
      border-radius:20px;
      background: radial-gradient(circle at 0 0, rgba(0,255,255,.14), rgba(0,0,0,.86));
      backdrop-filter: blur(14px) saturate(160%);
      box-shadow: var(--shadow-soft);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:60vh;
      overflow-y:auto;
      animation: fadeInUp var(--slow) ease forwards;
    }

    @keyframes fadeInUp { from { opacity:0; transform:translateY(12px); } to { opacity:1; transform:translateY(0); } }

    .pages-wrapper { width:100%; display:flex; flex-direction:column; gap:10px; }
    .page { display:none; opacity:0; transition:opacity var(--med) ease; }
    .page.active { display:block; opacity:1; }
    .page.initial { min-height:90px; display:flex; align-items:center; justify-content:center; text-align:center; }

    #bootText { font-weight:700; position:relative; letter-spacing:.03em; }
    #bootText.pulse::after {
      content: attr(data-text);
      position:absolute; inset:0;
      background:linear-gradient(42deg,#0ff,#f0f);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      filter:blur(4px); opacity:.45; pointer-events:none; animation:pulseGlow 3s ease-in-out infinite;
    }
    @keyframes pulseGlow { 0%,100% { opacity:0.4; } 50% { opacity:0.9; } }

    .response-block { margin:.35rem 0; padding:1rem 1.1rem; border-radius:14px; line-height:1.7; font-size:.9rem; position:relative; overflow:hidden; border:1px solid rgba(255,255,255,.04); transition: box-shadow var(--fast), transform var(--fast), border-color var(--fast), background var(--fast); cursor:default; background: linear-gradient(135deg, rgba(255,255,255,.02), rgba(6,10,28,.95)); }
    .response-block:hover { transform:translateY(-1px); box-shadow:0 12px 30px rgba(0,0,0,.7); border-color:rgba(0,255,255,.3); }
    .response-block.intro { background:linear-gradient(135deg, rgba(0,255,255,.18), rgba(0,40,70,.9)); }
    .response-block.middle { background:linear-gradient(135deg, rgba(255,255,255,.04), rgba(6,10,28,.95)); }
    .response-block.ending { background:linear-gradient(135deg, rgba(255,0,255,.18), rgba(40,0,60,.95)); }

    .response-block h1, .response-block h2, .response-block h3 { margin-bottom:.2rem; }
    .response-block h3 { font-size:.95rem; }

    .response-block code { font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New"; font-size:.8rem; padding:.15rem .32rem; border-radius:6px; background:rgba(0,0,0,.5); }

    .response-block ul { padding-left:18px; margin:.35rem 0; }
    .response-block li { margin-bottom:2px; }

    .lv-callout { border-radius:12px; padding:6px 8px; margin:4px 0; font-size:.8rem; line-height:1.5; }
    .lv-callout.info { border:1px solid rgba(0,255,255,.45); background:rgba(0,255,255,.06); }
    .lv-callout.warn { border:1px solid rgba(255,200,0,.6); background:rgba(255,200,0,.06); }
    .lv-callout.success { border:1px solid rgba(0,255,160,.6); background:rgba(0,255,160,.06); }
    .lv-callout.question { border:1px solid rgba(180,140,255,.7); background:rgba(180,140,255,.06); }
    .lv-callout.aside { border:1px dashed rgba(255,255,255,.4); background:rgba(255,255,255,.03); }

    .footer-text { margin-top:4px; padding:6px 10px; font-size:.78rem; text-align:center; opacity:.8; border-radius:999px; border:1px solid rgba(255,255,255,.16); background:rgba(0,0,0,.65); cursor:pointer; transition:opacity var(--fast), transform var(--fast), box-shadow var(--fast), background var(--fast); display:inline-flex; align-items:center; justify-content:center; gap:6px; }
    .footer-dot { width:6px; height:6px; border-radius:50%; background:linear-gradient(45deg,#0ff,#f0f); box-shadow:0 0 12px rgba(0,255,255,.7); }
    .footer-text:hover { opacity:.95; transform:scale(1.02); box-shadow:0 0 18px rgba(0,255,255,.35); background:rgba(0,0,0,.9); }

    .response-controls { margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,.12); display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:.8rem; }
    .control-buttons, .pagination { display:flex; align-items:center; gap:8px; }

    .icon-btn { width:30px; height:30px; border-radius:50%; border:none; background:rgba(0,0,0,.7); display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background var(--fast), transform var(--fast), opacity var(--fast); opacity:.85; color:var(--accent); font-size:.8rem; }
    .icon-btn:hover { background:rgba(255,255,255,.12); transform:translateY(-1px); opacity:1; }

    .pagination button { border:none; background:none; font-size:1.1rem; cursor:pointer; background:linear-gradient(45deg,#0ff,#f0f); -webkit-background-clip:text; -webkit-text-fill-color:transparent; transition:transform var(--fast), opacity var(--fast); opacity:.8; }
    .pagination button:hover { transform:scale(1.15); opacity:1; }

    #pageIndicator { font-size:.78rem; opacity:.8; }

    #iaConfigPanel { margin-top:6px; padding:8px 10px; border-radius:16px; background:rgba(0, 8, 20, .96); border:1px solid rgba(0,255,255,.24); box-shadow:0 8px 24px rgba(0,0,0,.5); font-size:.78rem; display:none; flex-direction:column; gap:6px; }
    #iaConfigPanel.active { display:flex; }

    #iaConfigHeader { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    #iaConfigHeader span { font-size:.78rem; text-transform:uppercase; letter-spacing:.08em; opacity:.9; }

    .ia-close-btn{ border:none; border-radius:999px; background:rgba(0,0,0,.7); color:rgba(255,255,255,.9); width:24px; height:24px; display:flex; align-items:center; justify-content:center; font-size:.8rem; cursor:pointer; box-shadow:0 0 0 1px rgba(255,255,255,.25); transition:background .2s, box-shadow .2s, transform .2s; }
    .ia-close-btn:hover{ background:rgba(255,255,255,.12); box-shadow:0 0 10px rgba(0,255,255,.5); transform:translateY(-1px); }

    .ia-config-body { display:flex; flex-direction:column; gap:6px; margin-top:4px; }
    .ia-field { display:flex; flex-direction:column; gap:3px; }
    .ia-field label { font-size:.72rem; opacity:.8; }
    .ia-field input, .ia-field select { width:100%; border-radius:8px; border:1px solid rgba(0,255,255,.3); background:rgba(0,0,0,.7); color:inherit; padding:5px 7px; font-size:.78rem; outline:none; }
    .ia-field input::placeholder { color:rgba(255,255,255,.38); }

    .ia-actions { display:flex; gap:6px; margin-top:4px; }
    .pill-btn { flex:1; border-radius:999px; border:1px solid rgba(0,255,255,.6); background:transparent; padding:5px 0; font-size:.78rem; cursor:pointer; color:var(--accent); transition:background var(--fast), color var(--fast), transform var(--fast); }
    .pill-btn:hover { background:var(--accent); color:#050515; transform:translateY(-1px); }
    .pill-btn.secondary { border-color:rgba(255,255,255,.35); color:rgba(255,255,255,.8); }
    .pill-btn.secondary:hover { background:rgba(255,255,255,.12); color:#fff; }

    .ia-status { font-size:.7rem; opacity:.8; margin-top:2px; }
    .ia-status.ok { color:#63f8ba; }
    .ia-status.warn { color:#ffd480; }
    .ia-status.err { color:var(--danger); }

    .input-container { display:flex; gap:8px; align-items:center; }
    #userInput { flex:1; min-width:0; padding:11px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.16); background:rgba(0,0,0,.7); color:inherit; font-size:.95rem; outline:none; transition:border-color var(--fast), background var(--fast), box-shadow var(--fast); }
    #userInput::placeholder { color:rgba(255,255,255,.35); }
    #userInput:focus { border-color:rgba(0,255,255,.65); background:rgba(0,0,0,.9); box-shadow:0 0 0 1px rgba(0,255,255,.45); }

    #sendBtn { width:50px; height:50px; border-radius:50%; border:none; background:conic-gradient(from 120deg,#0ff,#f0f,#0ff); display:flex; align-items:center; justify-content:center; font-size:1.4rem; color:#050515; cursor:pointer; box-shadow:0 0 18px rgba(0,255,255,.55); transition:transform var(--fast), box-shadow var(--fast); }
    #sendBtn:hover { transform:translateY(-1px) scale(1.04); box-shadow:0 0 26px rgba(0,255,255,.8); }

    #voiceBtn { width:46px; height:46px; border-radius:50%; border:none; background:rgba(0,0,0,.75); display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 0 0 1px rgba(255,255,255,.08); transition:transform var(--fast), box-shadow var(--fast), background var(--fast); color:var(--accent); font-size:1rem; }
    #voiceBtn:hover { transform:translateY(-1px); box-shadow:0 0 18px rgba(0,255,255,.45); background:rgba(0,0,0,.95); }
    #voiceBtn.recording { box-shadow:0 0 22px rgba(0,255,180,.8); background:radial-gradient(circle at 30% 0, rgba(0,255,180,.7), rgba(0,0,0,.9)); }

    .dual-chat-module.collapsed .pages-wrapper,
    .dual-chat-module.collapsed .response-controls,
    .dual-chat-module.collapsed #iaConfigPanel { display:none; }
    .dual-chat-module.collapsed .response-container { padding:6px 10px; }
    .dual-chat-module.collapsed .footer-text { margin-top:0; font-size:.78rem; }
    .dual-chat-module.collapsed .input-container { display:none; }

    .response-container::-webkit-scrollbar { width:4px; }
    .response-container::-webkit-scrollbar-thumb { background:rgba(255,255,255,.35); border-radius:999px; }

    @media (max-width:420px){
      .dual-chat-module { width: calc(100% - 24px); left: 50%; transform: translateX(-50%); }
      .response-container { max-height:50vh; padding:10px; }
      #sendBtn { width:44px; height:44px; font-size:1.1rem; }
    }
  </style></head>
<body>

  <!-- Cinematic Elements -->
  <div id="snap-zone"></div>
  <div class="ambient-light"><div class="blob blob-1"></div><div class="blob blob-2"></div></div>
  <div id="particles-js"><canvas class="particles-js-canvas-el"></canvas></div>

  <div class="svg-container">
    <object data="3D_logo_Dual_Infodose_9.svg" type="image/svg+xml"></object>
  </div>

  <div class="top-info" id="topInfo">
    <span id="displayUser">User: —</span> · <span id="displayInfodose">Infodose: —</span>
  </div>

  <div class="container">
    <div class="fusion-card closed" id="mainCard">

      <div class="card-header" id="cardHeader">
        <div class="avatar-slot" id="avatarTarget" title="Gerenciar Chaves (Cofre)"></div>
        <div class="text-block">
          <div class="greeting-row">
            <span class="txt-thin" id="lblHello">Oi,</span>
            <span class="txt-heavy" id="lblName">Convidado</span>
          </div>
          <div class="brand-dual">DUAL</div>
        </div>
        <div class="clock-widget">
          <div class="time-display" id="clockTime">00:00</div>
          <span class="status-led">ONLINE</span>
        </div>
        <!-- Button visible only in HUD mode -->
        <button class="hud-menu-btn" id="hudMenuBtn" title="Menu Rápido"><i data-lucide="menu"></i></button>
      </div>
      
      <!-- Trigger visible only on Orb Hover -->
      <div class="orb-menu-trigger" id="orbMenuTrigger" title="Menu Rápido">●●●</div>
      <!-- Drag Handle for HUD -->
      <div class="drag-handle"></div>

      <div class="small-preview" id="smallPreview" title="Gerenciar Chaves">
        <div class="mini-avatar" id="smallMiniAvatar"></div>
        <div class="small-text" id="smallText">Aguardando ativação...</div>
        <div class="ident-badge" id="smallIdent">--</div>
      </div>

      <div class="card-body" id="cardBody">
        <!-- Main Input User -->
        <div class="input-wrapper stagger-item">
          <input type="text" class="cyber-input" id="inputUser" placeholder="Identifique-se..." autocomplete="off">
        </div>

        <!-- Section 1: ASCII Activation -->
        <div class="activation-wrap stagger-item">
          <div class="activation-toggle" onclick="toggleSection('activationCard')">
            <div style="display:flex;align-items:center;gap:8px">
              <div style="width:10px;height:10px;border-radius:99px;background:var(--neon-cyan)"></div>
              <strong style="letter-spacing:1px;font-size:0.9rem">Ativação ASCII</strong>
            </div>
            <div style="margin-left:auto;font-size:0.82rem;color:rgba(255,255,255,0.6)">BASE v1</div>
          </div>
          <div id="activationCard" class="activation-card activation-hidden">
            <div style="display:flex;align-items:flex-start;gap:10px">
              <div style="display:flex;align-items:center;gap:8px">
                <div class="mini-avatar" id="actMiniAvatar"></div>
                <div><div style="font-weight:700">CÉREBRO</div><div style="font-size:0.78rem;opacity:0.6"><span id="actName">User</span></div></div>
              </div>
              <div class="activation-badge" id="actBadge" style="margin-left:auto">v:--</div>
            </div>
            <pre id="actPre" class="activation-pre">Carregando...</pre>
            <div class="activation-controls" style="display:flex;gap:8px;margin-top:8px">
              <button class="trigger-btn" id="copyActBtn">COPIAR</button>
              <button class="trigger-btn" id="downloadActBtn">PNG</button>
            </div>
          </div>
        </div>

        <!-- Section 2: System & Neural (Config) - Embedded in Card -->
        <div class="activation-wrap stagger-item">
            <div class="activation-toggle" onclick="toggleSection('systemCard')">
                <div style="display:flex;align-items:center;gap:8px">
                  <div style="width:10px;height:10px;border-radius:99px;background:var(--neon-purple)"></div>
                  <strong style="letter-spacing:1px;font-size:0.9rem">SYSTEM &amp; NEURAL</strong>
                </div>
                <div style="margin-left:auto;font-size:0.82rem;color:rgba(255,255,255,0.6)">CONFIG</div>
            </div>
            <div id="systemCard" class="activation-card activation-hidden">
                <div class="col">
                   <div class="section-title">IDENTIDADE DA INFODOSE</div>
                   <input type="text" id="infodoseNameInput" placeholder="Nome: World System..." style="width:100%;margin-bottom:8px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   
                   <div class="section-title" style="margin-top:8px">CONEXÃO NEURAL (SK)</div>
                   <input type="password" id="apiKeyInput" placeholder="sk-or-..." autocomplete="off" style="width:100%;margin-bottom:6px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   <input type="text" id="modelInput" placeholder="Modelo AI..." style="width:100%;margin-bottom:8px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.1);color:#fff">
                   
                   <div class="section-title" style="margin-top:8px">TREINAMENTO</div>
                   <div style="display:flex;gap:6px">
                       <input type="file" id="trainingUpload" accept=".txt" style="display:none">
                       <button class="trigger-btn" onclick="document.getElementById('trainingUpload').click()" style="padding:8px;flex:1">UPLOAD .TXT</button>
                       <button id="exportTrainingBtn" class="trigger-btn" style="padding:8px;flex:1">BAIXAR</button>
                   </div>
                   <div id="trainingFileName" class="small" style="margin-top:4px;color:#9bd;font-size:0.75rem">Vazio</div>

                   <div class="panel-divider" style="margin:10px 0"></div>

                   <div style="display:flex; flex-direction:column; gap:6px;">
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="assistantActiveCheckbox"> <label>Infodose Ativa</label>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="trainingActiveCheckbox"> <label>Treinamento Ativo</label>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;font-size:0.85rem">
                            <input type="checkbox" id="zenModeCheckbox"> <label>Modo Zen</label>
                        </div>
                   </div>

                   <button id="saveSystemBtn" class="trigger-btn" style="margin-top:12px;background:var(--neon-cyan);color:#000;border:none;font-weight:700">SALVAR CONFIGURAÇÃO</button>
                </div>
            </div>
        </div>

        <div class="stagger-item" style="margin-top:4px">
            <div class="stat-lbl" style="margin-bottom:6px">INTERFACE MODE</div>
            <div style="display:flex; gap:8px;">
                <button class="trigger-btn mode-btn active-mode" id="btnModeCard" onclick="setMode('card')" style="flex:1" title="Modo Padrão">CARD</button>
                <button class="trigger-btn mode-btn" id="btnModeOrb" onclick="setMode('orb')" style="flex:1" title="Flutuante">ORB</button>
                <button class="trigger-btn mode-btn" id="btnModeHud" onclick="setMode('hud')" style="flex:1" title="Barra de Topo">HUD</button>
            </div>
        </div>

        <div class="stagger-item">
          <div class="stats-grid">
            <div class="stat-box"><span class="stat-lbl">LATÊNCIA</span><span class="stat-val">12ms</span></div>
            <div class="stat-box"><span class="stat-lbl">SEGURANÇA</span><span class="stat-val" id="securityStatus">ABERTO</span></div>
            <div class="stat-box"><span class="stat-lbl">RITMO</span><span class="stat-val">BETA</span></div>
          </div>
          <div class="progress-container" style="margin-top:12px">
            <div class="bar-meta"><span>CICLO DIÁRIO</span><span id="cyclePercent">0%</span></div>
            <div class="bar-track"><div class="bar-fill" id="cycleFill"></div></div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="toaster-wrap" id="toasterWrap"></div>

  <!-- KEYS MANAGER MODAL -->
  <div id="keysModal" class="modal-overlay" aria-hidden="true">
    <div class="keys-card" role="dialog">
      <div class="keys-header">
        <div>
          <div id="keysTitle" style="font-weight:800;font-size:1.1rem;color:var(--neon-cyan)">USER KEYS MANAGER</div>
          <div style="color:rgba(255,255,255,0.6);font-size:0.85rem">Gerencie suas chaves API com segurança local (Cofre).</div>
        </div>
        <button id="closeKeysBtn" class="small-btn">X</button>
      </div>
      <div class="key-list" id="keyList"></div>
      <div class="form-section">
        <div class="form-grid">
          <input id="keyNameInput" placeholder="Nome da chave (ex: Principal)">
          <input id="keyTokenInput" type="password" placeholder="Token / ESK (Opcional)">
        </div>
        <div class="form-row">
          <input id="keyWebhookInput" placeholder="Webhook URL (https://...)" style="flex:1">
          <button id="testWebhookBtn" class="small-btn" title="Testar Conexão">PING</button>
        </div>
        <button id="addKeyBtn" class="small-btn" style="width:100%;margin-top:8px;background:rgba(255,255,255,0.1)">ADICIONAR CHAVE</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:space-between;margin-top:15px;border-top:1px solid rgba(255,255,255,0.05);padding-top:12px">
        <div style="font-size:0.7rem;color:rgba(255,255,255,0.4);display:flex;align-items:center;gap:5px">
          <i data-lucide="shield-check" style="width:14px"></i> <span id="vaultStatusText">Cofre Aberto</span>
        </div>
        <div style="display:flex;gap:8px">
          <button id="lockVaultBtn" class="small-btn danger">BLOQUEAR</button>
          <button id="exportKeysBtn" class="small-btn">Export</button>
          <button id="importKeysBtn" class="small-btn">Import</button>
          <input id="importFileInput" type="file" accept="application/json" style="display:none">
        </div>
      </div>
    </div>
  </div>

  <!-- VAULT UNLOCK MODAL -->
  <div id="vaultModal" class="modal-overlay" aria-hidden="true">
    <div class="keys-card">
      <div class="vault-icon"><i data-lucide="lock" style="width:24px;height:24px"></i></div>
      <h3 style="margin:0 0 10px 0;font-weight:800">ACESSO AO COFRE</h3>
      <p style="margin:0 0 15px 0;font-size:0.9rem;color:rgba(255,255,255,0.6)">Seus dados estão criptografados. Digite a senha para desbloquear.</p>
      <input type="password" id="vaultPassInput" class="cyber-input" style="text-align:center;margin-bottom:12px" placeholder="Senha...">
      <div style="display:flex;gap:8px;justify-content:center">
         <button id="vaultCancelBtn" class="small-btn">Cancelar</button>
         <button id="vaultUnlockBtn" class="small-btn active-btn">DESBLOQUEAR</button>
      </div>
    </div>
  </div>

  <div class="response-container" id="response">
    <div class="page initial active">
      <strong>Clique no ◉ e diga “Oi, Dual”.</strong><br>
      <em>Sempre único. Sempre seu.</em>
    </div>
    <div class="response-controls">
      <div class="control-buttons">
        <button class="control-btn copy-button" title="Copiar tudo">
          <svg viewBox="0 0 24 24" width="20"><circle cx="12" cy="12" r="10"></circle><rect x="6" y="6" width="12" height="12"></rect></svg>
        </button>
        <button class="control-btn paste-button" title="Colar">
          <svg viewBox="0 0 24 24" width="20"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="4" x2="12" y2="20"></line></svg>
        </button>
        <button id="toggleBtn" class="control-btn toggle-button" title="Check Connection &amp; Training">
          <!-- Toggle Icon (Power/Signal hybrid) -->
          <svg viewBox="0 0 24 24" width="20" height="20" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
            <line x1="12" y1="2" x2="12" y2="12"></line>
          </svg>
        </button>
        <button id="crystalBtn" class="control-btn" title="Cristalizados">
          <svg viewBox="0 0 24 24" width="20" height="20"><path d="M12 2l2.9 6.3L21 10l-5 3.6L17.8 21 12 17.7 6.2 21 7 13.6 2 10l6.1-1.7L12 2z"></path></svg>
        </button>
      </div>
      <div class="pagination">
        <button data-action="prev">⟵</button>
        <span id="pageIndicator">1 / 1</span>
        <button data-action="next">⟶</button>
      </div>
    </div>
  </div>

  <div class="input-container">
    <input id="userInput" type="text" placeholder="Diga: 'oi, Dual'...">
    <button id="sendBtn" title="Enviar">➤</button>
    <button id="voiceBtn" title="Falar">
      <object data="Reset_buttom_Dual-Infodose.svg" type="image/svg+xml" width="36" height="36" style="pointer-events: none;"></object>
    </button>
  </div>

  <div id="crystalModal" class="modal">
    <div class="box">
      <h3>Cristalizados</h3>
      <div class="row" style="margin-bottom:8px">
        <button id="exportAllCrystal" class="btn btn-prim">Exportar todos</button>
        <button id="clearAllCrystal" class="btn btn-sec">Limpar tudo</button>
      </div>
      <div class="crystal-list" id="crystalList"></div>
      <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
        <button id="closeCrystal" class="btn btn-sec">Fechar</button>
      </div>
    </div>
  </div>

  <div id="mantra-toggle">
    <span id="mantra-text">Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.</span>
  </div>


  <script>
    lucide.createIcons();

    const els = {
      card: document.getElementById('mainCard'),
      header: document.getElementById('cardHeader'),
      avatarTgt: document.getElementById('avatarTarget'),
      input: document.getElementById('inputUser'),
      lblHello: document.getElementById('lblHello'),
      lblName: document.getElementById('lblName'),
      clock: document.getElementById('clockTime'),
      smallPreview: document.getElementById('smallPreview'),
      smallMiniAvatar: document.getElementById('smallMiniAvatar'),
      smallText: document.getElementById('smallText'),
      smallIdent: document.getElementById('smallIdent'),
      actCard: document.getElementById('activationCard'),
      actPre: document.getElementById('actPre'),
      actName: document.getElementById('actName'),
      actMiniAvatar: document.getElementById('actMiniAvatar'),
      actBadge: document.getElementById('actBadge'),
      securityStatus: document.getElementById('securityStatus'),
      // Buttons
      btnModeCard: document.getElementById('btnModeCard'),
      btnModeOrb: document.getElementById('btnModeOrb'),
      btnModeHud: document.getElementById('btnModeHud'),
      orbMenuTrigger: document.getElementById('orbMenuTrigger'),
      hudMenuBtn: document.getElementById('hudMenuBtn'),
      snapZone: document.getElementById('snap-zone'),
      // Keys UI
      keysModal: document.getElementById('keysModal'),
      keyList: document.getElementById('keyList'),
      keyName: document.getElementById('keyNameInput'),
      keyToken: document.getElementById('keyTokenInput'),
      keyWebhook: document.getElementById('keyWebhookInput'),
      addKeyBtn: document.getElementById('addKeyBtn'),
      closeKeysBtn: document.getElementById('closeKeysBtn'),
      testWebhookBtn: document.getElementById('testWebhookBtn'),
      exportKeysBtn: document.getElementById('exportKeysBtn'),
      importKeysBtn: document.getElementById('importKeysBtn'),
      importFileInput: document.getElementById('importFileInput'),
      lockVaultBtn: document.getElementById('lockVaultBtn'),
      vaultStatusText: document.getElementById('vaultStatusText'),
      // Vault UI
      vaultModal: document.getElementById('vaultModal'),
      vaultPass: document.getElementById('vaultPassInput'),
      vaultUnlock: document.getElementById('vaultUnlockBtn'),
      vaultCancel: document.getElementById('vaultCancelBtn'),
      // New System UI
      systemCard: document.getElementById('systemCard'),
      toggleBtn: document.getElementById('toggleBtn')
    };

    // --- CRYPTO UTILS ---
    const CRYPTO = {
      algo: { name: 'AES-GCM', length: 256 },
      pbkdf2: { name: 'PBKDF2', hash: 'SHA-256', iterations: 100000 },
      salt: window.crypto.getRandomValues(new Uint8Array(16)), 
      async getKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
        return window.crypto.subtle.deriveKey({ ...this.pbkdf2, salt: salt }, keyMaterial, this.algo, false, ["encrypt", "decrypt"]);
      },
      async encrypt(data, password) {
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const key = await this.getKey(password, salt);
        const encoded = new TextEncoder().encode(JSON.stringify(data));
        const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encoded);
        const bundle = { s: Array.from(salt), iv: Array.from(iv), d: Array.from(new Uint8Array(encrypted)) };
        return JSON.stringify(bundle);
      },
      async decrypt(bundleStr, password) {
        try {
          const bundle = JSON.parse(bundleStr);
          const salt = new Uint8Array(bundle.s);
          const iv = new Uint8Array(bundle.iv);
          const data = new Uint8Array(bundle.d);
          const key = await this.getKey(password, salt);
          const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
          return JSON.parse(new TextDecoder().decode(decrypted));
        } catch(e) { throw new Error("Senha incorreta ou dados corrompidos"); }
      }
    };

    // --- STATE & PERSISTENCE ---
    const STORAGE_KEY = 'fusion_os_data_v2';
    const UI_STATE_KEY = 'fusion_os_ui_state';
    
    let STATE = {
      keys: [], 
      user: 'Convidado',
      isEncrypted: false,
      encryptedData: null
    };
    let SESSION_PASSWORD = null;

    function saveUIState() {
        const mode = state.isOrb ? 'orb' : (state.isHud ? 'hud' : 'card');
        const uiState = {
            mode: mode,
            left: els.card.style.left,
            top: els.card.style.top,
            zen: document.body.classList.contains('zen-mode')
        };
        localStorage.setItem(UI_STATE_KEY, JSON.stringify(uiState));
    }
    
    function loadUIState() {
        const raw = localStorage.getItem(UI_STATE_KEY);
        if(!raw) return;
        try {
            const ui = JSON.parse(raw);
            if(ui.zen) {
                document.body.classList.add('zen-mode');
                document.getElementById('mantra-toggle').classList.add('collapsed');
                if(document.getElementById('zenModeCheckbox')) document.getElementById('zenModeCheckbox').checked = true;
            }
            if (ui.mode === 'orb' || ui.mode === 'hud') {
                els.card.style.transition = 'none'; 
                if (ui.mode === 'orb') {
                    if(ui.left) els.card.style.left = ui.left;
                    if(ui.top) els.card.style.top = ui.top;
                    window.setMode('orb', true);
                } else {
                    window.setMode('hud', true);
                }
                setTimeout(() => els.card.style.transition = '', 200);
            }
        } catch(e) { console.error("UI Load Error", e); }
    }

    function saveData() {
      const payload = { keys: STATE.keys, user: STATE.user };
      if (SESSION_PASSWORD) {
        CRYPTO.encrypt(payload, SESSION_PASSWORD).then(enc => {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: true, data: enc }));
          STATE.isEncrypted = true;
          STATE.encryptedData = enc;
          updateSecurityUI();
        });
      } else {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ isEncrypted: false, data: payload }));
      }
    }

    async function loadData() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (parsed.isEncrypted) {
        STATE.isEncrypted = true;
        STATE.encryptedData = parsed.data;
        updateSecurityUI();
      } else {
        STATE.keys = parsed.data.keys || [];
        STATE.user = parsed.data.user || 'Convidado';
        
        const active = STATE.keys.find(k=>k.active);
        if(active && active.token) {
           localStorage.setItem('di_apiKey', active.token);
           if(typeof apiKey !== 'undefined') apiKey = active.token;
        }
        
        if(STATE.user !== 'Convidado') {
           localStorage.setItem('di_userName', STATE.user);
           if(typeof userName !== 'undefined') userName = STATE.user;
           if(document.getElementById('userNameInput')) document.getElementById('userNameInput').value = STATE.user;
           if(document.getElementById('inputUser')) document.getElementById('inputUser').value = STATE.user;
        }

        updateInterface(STATE.user);
        renderKeysList();
      }
    }

    const hashStr = s => { let h=0xdeadbeef; for(let i=0;i<s.length;i++){h=Math.imul(h^s.charCodeAt(i),2654435761);} return (h^h>>>16)>>>0; };
    const createSvg = (id,sz) => `<svg viewBox="0 0 100 100" width="${sz}" height="${sz}"><defs><linearGradient id="g${id}"><stop offset="0%" stop-color="#00f2ff"/><stop offset="100%" stop-color="#bd00ff"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="#080b12" stroke="rgba(255,255,255,0.1)"/><circle cx="50" cy="50" r="20" fill="url(#g${id})" opacity="0.9"/></svg>`;
    const createMiniSvg = (name,sz=30) => {
      const s = hashStr(name||'D'); const h1=s%360; const h2=(s*37)%360;
      const grad = `<linearGradient id="gm${s}" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="hsl(${h1},90%,50%)"/><stop offset="1" stop-color="hsl(${h2},90%,50%)"/></linearGradient>`;
      return `<svg width="${sz}" height="${sz}" viewBox="0 0 32 32"><defs>${grad}</defs><rect width="32" height="32" rx="8" fill="#0a1016"/><circle cx="16" cy="16" r="6" fill="url(#gm${s})"/></svg>`;
    };

    function updateInterface(name){
      const safe = name || 'Convidado';
      els.lblName.innerText = safe;
      els.input.value = safe;
      const activeKey = STATE.keys.find(k=>k.active);
      els.smallIdent.innerText = activeKey ? activeKey.name : '--';
      els.actBadge.innerText = activeKey ? `key:${activeKey.name}` : 'v:--';
      els.smallMiniAvatar.innerHTML = createMiniSvg(safe);
      els.actMiniAvatar.innerHTML = createMiniSvg(safe,36);
      els.actName.innerText = safe;
      els.avatarTgt.innerHTML = createSvg('Main',64);
      const phrases = ["Foco estável.","Ritmo criativo.","Percepção sutil."];
      els.smallText.innerText = activeKey ? `${activeKey.name} [ATIVO]` : (safe==='Convidado'?'Aguardando...':`${safe} · ${phrases[safe.length%phrases.length]}`);
      const line = `+${'-'.repeat(safe.length+4)}+`;
      els.actPre.innerText = `${line}\n| ${safe.toUpperCase()} |\n${line}\nID: ${hashStr(safe).toString(16)}`;

      const tiUser = document.getElementById('displayUser');
      if(tiUser) tiUser.innerText = 'User: ' + safe;
    }

    function updateSecurityUI() {
      if (SESSION_PASSWORD) {
        els.securityStatus.innerText = "COFRE DESTRANCADO"; els.securityStatus.style.color = "var(--neon-success)";
        els.vaultStatusText.innerText = "Cofre Protegido (Destrancado)"; els.lockVaultBtn.innerText = "TRANCAR";
      } else if (STATE.isEncrypted) {
        els.securityStatus.innerText = "CRIPTOGRAFADO"; els.securityStatus.style.color = "var(--neon-gold)";
        els.vaultStatusText.innerText = "Cofre Trancado"; els.lockVaultBtn.innerText = "REDEFINIR";
      } else {
        els.securityStatus.innerText = "SEM PROTEÇÃO"; els.securityStatus.style.color = "rgba(255,255,255,0.5)";
        els.vaultStatusText.innerText = "Cofre Aberto (Sem senha)"; els.lockVaultBtn.innerText = "CRIAR SENHA";
      }
    }

    function renderKeysList(){
      els.keyList.innerHTML = '';
      if(STATE.keys.length===0){ els.keyList.innerHTML = '<div style="color:rgba(255,255,255,0.3);text-align:center;padding:20px">Nenhuma chave armazenada.</div>'; return; }
      STATE.keys.forEach(k=>{
        const div = document.createElement('div');
        div.className = `key-item ${k.active?'active-item':''}`;
        const typeInfo = k.webhook ? '<span style="color:var(--neon-purple)">WEBHOOK</span>' : 'API KEY';
        div.innerHTML = `
          <div class="meta"><div style="font-weight:700;font-size:0.9rem">${escapeHtml(k.name)}</div><div style="font-size:0.75rem;color:rgba(255,255,255,0.5)">${typeInfo}</div></div>
          <div class="actions">
            ${!k.active ? `<button class="small-btn" onclick="setActiveKey('${k.id}')">ATIVAR</button>` : `<span style="font-size:0.7rem;font-weight:700;color:var(--neon-cyan);margin-right:10px">ATIVA</span>`}
            <button class="small-btn danger" onclick="removeKey('${k.id}')"><i data-lucide="trash-2" style="width:14px"></i></button>
          </div>`;
        els.keyList.appendChild(div);
      });
      lucide.createIcons();
    }

    function addKey() {
      const name = els.keyName.value.trim();
      const token = els.keyToken.value.trim();
      const webhook = els.keyWebhook.value.trim();
      if(!name){ showToaster('Nome obrigatório','error'); return; }
      const newKey = { id: Date.now().toString(36), name, token, webhook, active: STATE.keys.length===0 };
      STATE.keys.push(newKey);
      if(newKey.active && newKey.token) {
        localStorage.setItem('di_apiKey', newKey.token);
        if(typeof apiKey !== 'undefined') apiKey = newKey.token;
      }
      saveData(); renderKeysList(); updateInterface(STATE.user);
      els.keyName.value=''; els.keyToken.value=''; els.keyWebhook.value='';
      showToaster('Chave adicionada!', 'success');
    }

    window.removeKey = (id) => {
      if(confirm('Remover chave permanentemente?')){
        STATE.keys = STATE.keys.filter(k=>k.id!==id);
        saveData(); renderKeysList(); updateInterface(STATE.user);
      }
    };

    window.setActiveKey = (id) => {
      let activatedToken = null;
      STATE.keys.forEach(k=> {
        k.active = (k.id===id);
        if(k.active) activatedToken = k.token;
      });
      if(activatedToken) {
        localStorage.setItem('di_apiKey', activatedToken);
        if(typeof apiKey !== 'undefined') apiKey = activatedToken;
        if(document.getElementById('apiKeyInput')) document.getElementById('apiKeyInput').value = activatedToken;
        showToaster('Chave sincronizada com o Chat.', 'success');
      }
      saveData(); renderKeysList(); updateInterface(STATE.user);
    };

    // --- VAULT EVENTS ---
    els.testWebhookBtn.addEventListener('click', async () => { showToaster('Ping enviado (simulado)','success'); });
    function openManager() {
      if (STATE.isEncrypted && !SESSION_PASSWORD) { els.vaultModal.style.display='flex'; els.vaultPass.focus(); } 
      else { els.keysModal.style.display='flex'; }
    }
    els.vaultUnlock.addEventListener('click', async () => {
      const pass = els.vaultPass.value;
      try {
        const decrypted = await CRYPTO.decrypt(STATE.encryptedData, pass);
        SESSION_PASSWORD = pass; STATE.keys = decrypted.keys; STATE.user = decrypted.user;
        const active = STATE.keys.find(k=>k.active);
        if(active && active.token) { localStorage.setItem('di_apiKey', active.token); if(typeof apiKey !== 'undefined') apiKey = active.token; }
        if(STATE.user) { localStorage.setItem('di_userName', STATE.user); if(typeof userName !== 'undefined') userName = STATE.user; }
        els.vaultModal.style.display='none'; els.keysModal.style.display='flex'; els.vaultPass.value='';
        renderKeysList(); updateSecurityUI(); showToaster('Cofre destrancado.', 'success');
      } catch(e) { showToaster('Senha incorreta.', 'error'); }
    });
    els.lockVaultBtn.addEventListener('click', () => {
       if (!SESSION_PASSWORD && !STATE.isEncrypted) {
         const newPass = prompt("Defina uma senha para o Cofre:");
         if(newPass) { SESSION_PASSWORD=newPass; saveData(); showToaster("Cofre trancado.", 'success'); }
       } else if (SESSION_PASSWORD) {
         SESSION_PASSWORD=null; els.keysModal.style.display='none'; showToaster("Sessão do cofre encerrada.", 'success');
       } else {
         showToaster("Cofre já criptografado. Desbloqueie para redefinir.", 'error');
       }
       updateSecurityUI();
    });
    els.vaultCancel.addEventListener('click', ()=> els.vaultModal.style.display='none');
    els.closeKeysBtn.addEventListener('click', ()=> els.keysModal.style.display='none');
    els.addKeyBtn.addEventListener('click', addKey);

    // --- CINEMATIC GESTURES & MODES (REFINED V7) ---

    let state = {
        isOrb: false,
        isHud: false,
        isDragging: false,
        timer: null,
        startX: 0,
        startY: 0,
        dragOffsetX: 0,
        dragOffsetY: 0,
        pointerId: null
    };

    const HUD_SNAP_THRESHOLD = 60; // Distância do topo para snapar
    const SWIPE_DOWN_THRESHOLD = 80; // Distância para puxar HUD
    const LONG_PRESS_MS = 350; // Tempo para virar Orb via long press

    // Passive: false para permitir preventDefault() se necessário
    els.card.addEventListener('pointerdown', handleStart, { passive: false });
    window.addEventListener('pointermove', handleMove, { passive: false });
    window.addEventListener('pointerup', handleEnd, { passive: false });

    // Opening Configs
    els.avatarTgt.addEventListener('click', (e)=>{ if(!state.isOrb && !state.isHud) openManager(); });
    els.orbMenuTrigger.addEventListener('click', (e)=>{ e.stopPropagation(); window.setMode('card'); toggleSection('systemCard', true); });
    els.hudMenuBtn.addEventListener('click', (e)=>{ e.stopPropagation(); window.setMode('card'); toggleSection('systemCard', true); });
    
    // Open Config from Header click in HUD Mode
    els.header.addEventListener('click', (e) => {
        if(state.isHud && !state.isDragging && !e.target.closest('.hud-menu-btn')) {
             window.setMode('card');
             toggleSection('systemCard', true);
        }
    });

    els.card.addEventListener('contextmenu', (e)=>{
        if(state.isOrb || state.isHud) { e.preventDefault(); window.setMode('card'); }
    });

    function handleStart(e) {
      // Ignorar interações internas (inputs, textareas)
      if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || (e.target.tagName === 'BUTTON' && !e.target.closest('.orb-menu-trigger'))) return;
      
      // No modo Card, só permitir arrastar pelo Header
      if(!state.isOrb && !state.isHud && !els.header.contains(e.target)) return;

      state.startX = e.clientX;
      state.startY = e.clientY;
      state.pointerId = e.pointerId;

      // Se já for Orb/Hud -> Iniciar arraste imediato
      if(state.isOrb || state.isHud) {
          state.isDragging = true;
          try { els.card.setPointerCapture(e.pointerId); } catch(err){}
          
          const rect = els.card.getBoundingClientRect();
          state.dragOffsetX = e.clientX - rect.left;
          state.dragOffsetY = e.clientY - rect.top;
          els.card.style.transition = 'none';
          return;
      }

      // Se for Card: Iniciar timer de Long Press, mas monitorar movimento para "swipe up"
      state.timer = setTimeout(() => {
          transmuteToOrb(e);
          saveUIState();
      }, LONG_PRESS_MS);
    }
    
    function handleMove(e) {
      // Detecção de Swipe Up / Side Drag no modo Card antes do timer acabar
      if(!state.isOrb && !state.isHud && state.timer) {
          const dx = e.clientX - state.startX;
          const dy = e.clientY - state.startY;
          const dist = Math.hypot(dx, dy);
          
          // Se moveu o suficiente (swipe), cancelar timer e virar Orb imediatamente
          // Lógica: Se arrastar pra cima (dy < -10) ou muito pros lados (dx > 18)
          if (dist > 12 && (dy < -10 || Math.abs(dx) > 18)) { 
              clearTimeout(state.timer); state.timer = null;
              
              // Transmutar e continuar arrastando
              transmuteToOrb(e); 
              
              // Recalcular offset para o drag não "pular"
              const rect = els.card.getBoundingClientRect();
              state.dragOffsetX = e.clientX - rect.left;
              state.dragOffsetY = e.clientY - rect.top;
              try { els.card.setPointerCapture(e.pointerId); } catch(err){}
              els.card.style.transition = 'none';
          }
          
          // Se foi um movimento pequeno (jitter), talvez cancelar se for scroll? 
          // Deixamos o browser decidir o scroll se não for drag.
      }
    
      if(!state.isDragging) return;

      e.preventDefault(); // Prevenir scroll da página enquanto arrasta o Orb/HUD

      if(state.isOrb) {
          const x = e.clientX - state.dragOffsetX;
          const y = e.clientY - state.dragOffsetY;
          els.card.style.left = `${x}px`;
          els.card.style.top = `${y}px`;
          
          if(y < HUD_SNAP_THRESHOLD) els.snapZone.classList.add('active');
          else els.snapZone.classList.remove('active');

      } else if (state.isHud) {
          const deltaY = e.clientY - state.startY;
          if(deltaY > 0) {
             els.card.style.transform = `translateX(-50%) translateY(${deltaY * 0.4}px)`;
             if(deltaY > SWIPE_DOWN_THRESHOLD) els.snapZone.classList.add('active');
             else els.snapZone.classList.remove('active');
          }
      }
    }
    
    function handleEnd(e) {
      if(state.timer){ clearTimeout(state.timer); state.timer=null; }
      
      if(state.isDragging) {
          state.isDragging = false;
          try { els.card.releasePointerCapture && els.card.releasePointerCapture(state.pointerId); } catch(err){}
          els.card.style.transition = ''; 
          els.snapZone.classList.remove('active');

          if(state.isOrb) {
              const rect = els.card.getBoundingClientRect();
              if(rect.top < HUD_SNAP_THRESHOLD) {
                  setMode('hud');
              } else {
                  saveUIState();
              }
          } else if (state.isHud) {
              const deltaY = e.clientY - state.startY;
              if (deltaY > SWIPE_DOWN_THRESHOLD) {
                  const x = e.clientX - 34; 
                  const y = e.clientY - 10;
                  els.card.style.left = `${x}px`;
                  els.card.style.top = `${y}px`;
                  setMode('orb');
              } else {
                  els.card.style.transform = `translateX(-50%) translateY(0)`;
              }
          }
      } else {
          // Clique simples no header do Card (Toggle)
          if(!state.isOrb && !state.isHud && els.header.contains(e.target)) {
               toggleCardState();
          }
      }
      state.pointerId = null;
    }
    
    function transmuteToOrb(eOrX) {
      // Aceita evento ou coordenadas, mas preferimos evento para capturar pointer
      let x, y, ev;
      if(eOrX && eOrX.clientX !== undefined) { ev = eOrX; x = ev.clientX; y = ev.clientY; }
      else { return; } // Precisa de evento para fluidez total

      if(navigator.vibrate) navigator.vibrate(40);
      els.card.classList.add('orb','closed'); 
      els.card.classList.remove('content-visible');
      
      // Centralizar visualmente (será sobrescrito pelo drag move imediato)
      els.card.style.left = (x - 34) + 'px'; 
      els.card.style.top = (y - 34) + 'px';
      
      state.isOrb=true; state.isHud=false;
      
      // Iniciar drag imediatamente
      state.isDragging = true;
      if(ev && ev.pointerId) {
          state.pointerId = ev.pointerId;
          try { els.card.setPointerCapture(ev.pointerId); } catch(e){}
          const rect = els.card.getBoundingClientRect();
          state.dragOffsetX = x - rect.left;
          state.dragOffsetY = y - rect.top;
      }

      updateModeButtons('orb');
    }

    function revertToCard() {
      state.isOrb=false; state.isHud=false;
      els.card.style.transition='all 0.5s var(--ease-smooth)'; 
      els.card.style.left=''; els.card.style.top=''; 
      els.card.style.width=''; els.card.style.height=''; 
      els.card.style.transform='';
      els.card.classList.remove('orb','hud','closed'); 
      setTimeout(()=>els.card.classList.add('content-visible'),300);
    }
    
    window.setMode = (mode, isInitialLoad = false) => {
        updateModeButtons(mode);

        if(mode === 'card') {
            revertToCard();
        } else if (mode === 'orb') {
            state.isOrb = true; state.isHud = false;
            els.card.classList.add('orb', 'closed');
            els.card.classList.remove('hud', 'content-visible');
            els.card.style.transform = 'none';
        } else if (mode === 'hud') {
            state.isHud = true; state.isOrb = false;
            els.card.classList.add('hud', 'closed'); 
            els.card.classList.remove('orb', 'content-visible');
            els.card.style.top = ''; 
            els.card.style.left = ''; 
            els.card.style.transform = '';
        }
        
        if(!isInitialLoad) saveUIState();
    };

    function updateModeButtons(mode) {
        [els.btnModeCard, els.btnModeOrb, els.btnModeHud].forEach(b=>b.classList.remove('active-mode'));
        if(mode==='card') els.btnModeCard.classList.add('active-mode');
        if(mode==='orb') els.btnModeOrb.classList.add('active-mode');
        if(mode==='hud') els.btnModeHud.classList.add('active-mode');
    }

    function toggleCardState() {
      if(els.card.classList.contains('animating')) return;
      const isClosed=els.card.classList.contains('closed'); els.card.classList.add('animating');
      if(isClosed) { els.card.classList.remove('closed'); els.card.animate([{transform:'scale(0.95)',opacity:0.8},{transform:'scale(1)',opacity:1}],{duration:400}).onfinish=()=>{els.card.classList.remove('animating');els.card.classList.add('content-visible');} }
      else { els.card.classList.remove('content-visible'); els.card.animate([{transform:'translateY(0)',opacity:1},{transform:'translateY(10px)',opacity:1}],{duration:200}).onfinish=()=>{els.card.classList.add('closed');els.card.classList.remove('animating');} }
    }
    
    // Helpers
    function escapeHtml(s){ return s ? s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) : ''; }
    function showToaster(txt,type='default'){ const t=document.createElement('div'); t.className=`toaster ${type}`; t.innerText=txt; document.getElementById('toasterWrap').appendChild(t); setTimeout(()=>t.classList.add('show'),10); setTimeout(()=>{t.classList.remove('show');setTimeout(()=>t.remove(),300)},2500); }
    function toggleSection(id, forceOpen = false){ 
        const el = document.getElementById(id);
        const h = el.classList.contains('activation-hidden'); 
        if(forceOpen && !h) return; // Already open
        el.classList.toggle('activation-hidden', !forceOpen && !h); 
        el.classList.toggle('activation-open', forceOpen || h); 
    }
    window.toggleActivation = () => toggleSection('activationCard');

    // Logic Init
    els.input.addEventListener('input', (e)=>{ 
       STATE.user=e.target.value; 
       localStorage.setItem('di_userName', STATE.user); 
       if(typeof userName !== 'undefined') userName=STATE.user;
       updateInterface(e.target.value); saveData(); 
    });
    
    // INITIAL LOAD
    setTimeout(()=>{ 
        els.card.classList.add('active'); 
        els.avatarTgt.classList.add('shown'); 
        loadData(); 
        loadUIState(); 
        updateChatUI();
    }, 100);
    setInterval(()=>{ els.clock.innerText = new Date().toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'}); },1000);
  </script>

  <script>
    const API_ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';
    const TEMPERATURE = 0.2;

    let training = localStorage.getItem('di_trainingText') || '';
    let trainingFileName = localStorage.getItem('di_trainingFileName') || '';
    let assistantEnabled = (localStorage.getItem('di_assistantEnabled') === '1');
    let trainingActive = (localStorage.getItem('di_trainingActive') !== '0'); 
    let conversation = [];
    let pages = [], currentPage = 0, autoAdvance = true;

    // Configs
    let apiKey = localStorage.getItem('di_apiKey') || '';
    let modelName = localStorage.getItem('di_modelName') || 'meta-llama/llama-4-maverick:free';
    let userName = localStorage.getItem('di_userName') || '';
    let infodoseName = localStorage.getItem('di_infodoseName') || '';
    const CRYSTAL_KEY = 'di_cristalizados';

    const createEl = (tag, cls, html) => { const e = document.createElement(tag); if (cls) e.className = cls; if (html) e.innerHTML = html; return e; };

    function updateChatUI() {
       const uEl = document.getElementById('displayUser');
       const iEl = document.getElementById('displayInfodose');
       if(uEl) uEl.innerText = 'User: ' + (userName || '—');
       if(iEl) iEl.innerText = 'Infodose: ' + (infodoseName || '—');
       
       // Settings Inputs
       if(document.getElementById('apiKeyInput')) document.getElementById('apiKeyInput').value = apiKey;
       if(document.getElementById('modelInput')) document.getElementById('modelInput').value = modelName;
       if(document.getElementById('infodoseNameInput')) document.getElementById('infodoseNameInput').value = infodoseName;
       
       // Toggles
       if(document.getElementById('assistantActiveCheckbox')) document.getElementById('assistantActiveCheckbox').checked = assistantEnabled;
       if(document.getElementById('trainingActiveCheckbox')) document.getElementById('trainingActiveCheckbox').checked = trainingActive;
       
       // Update Chat Toggle Button Visual
       updateToggleBtnVisual();
    }
    
    function updateToggleBtnVisual() {
        const btn = els.toggleBtn;
        if(assistantEnabled) {
            btn.classList.add('active');
            btn.title = "Assistant ON";
        } else {
            btn.classList.remove('active');
            btn.title = "Assistant OFF";
        }
    }

    // TTS Logic ... (Same as before)
    const speakText = (txt, onend)=> {
      if (!txt) { if (onend) onend(); return; }
      const u = new SpeechSynthesisUtterance(txt);
      u.lang = 'pt-BR'; u.rate = 0.99; u.pitch = 1.1;
      if (window._vozes) u.voice = window._vozes.find(v=>v.lang==='pt-BR') || window._vozes[0];
      if (onend) u.onend = onend;
      speechSynthesis.speak(u);
    };

    const splitBlocks = text => {
      if (!text || !text.trim()) return [['Sem conteúdo.','','']];
      let paras = text.split(/\n\s*\n/).filter(p=>p.trim());
      if (paras.length % 3 !== 0) {
        const sens = paras.join(' ').match(/[^\.!\?]+[\.!\?]+/g) || [paras.join(' ')];
        paras = sens.map(s=>s.trim());
      }
      const groups = [];
      for (let i=0;i<paras.length;i+=3) groups.push(paras.slice(i,i+3));
      return groups;
    };

    const renderPaginatedResponse = text => {
      speechSynthesis.cancel();
      autoAdvance = true;
      const respEl = document.getElementById('response');
      respEl.querySelectorAll('.page:not(.initial)').forEach(p=>p.remove());
      pages = [];
      const groups = splitBlocks(text);
      const controls = respEl.querySelector('.response-controls');
      const titles = ['🎁 Recompensa Inicial','👁️ Exploração e Curiosidade','⚡ Antecipação Vibracional'];

      groups.forEach((tris, gi) => {
        const page = createEl('div', gi===0?'page active':'page');
        tris.forEach((body, j) => {
          const cls = j===0?'intro': j===1?'middle':'ending';
          const b = createEl('div','response-block '+cls,`<h3>${titles[j]}</h3><p>${body}</p>`);
          const meta = createEl('div','meta');
          const crystalBtn = createEl('button','crystal-btn','✶');
          crystalBtn.title = 'Cristalizar';
          crystalBtn.addEventListener('click', (ev)=>{
            ev.stopPropagation(); cristalizar({ title: titles[j], content: body });
            crystalBtn.innerText = '✓'; setTimeout(()=> crystalBtn.innerText = '✶', 1200);
          });
          meta.appendChild(crystalBtn); b.appendChild(meta);

          b.dataset.state = '';
          b.addEventListener('click', () => {
            if (!b.dataset.state) {
              speechSynthesis.cancel(); speakText(body); b.classList.add('clicked'); b.dataset.state = 'spoken';
            } else {
              b.classList.add('expanded'); b.dataset.state = '';
              if (!assistantEnabled) {
                assistantEnabled = true; localStorage.setItem('di_assistantEnabled','1');
                updateToggleBtnVisual();
                if (training && trainingActive) conversation.unshift({ role:'system', content: training });
              }
              const blockText = `${titles[j]}\n\n${body}`;
              showLoading('Pulso em Expansão...'); speakText('Pulso em Expansão...');
              conversation.push({ role:'user', content: blockText });
              callAI();
            }
          });
          page.appendChild(b);
        });
        page.appendChild(createEl('p','footer-text',`<em>Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.</em>`));
        respEl.insertBefore(page, controls);
        pages.push(page);
      });
      currentPage = 0; document.getElementById('pageIndicator').textContent = `1 / ${pages.length}`;
      speakPage(0);
    };

    const speakPage = i => {
      const page = pages[i]; if (!page) return;
      const body = Array.from(page.querySelectorAll('.response-block p')).map(p=>p.innerText).join(' ');
      speakText(body, () => {
        if (!autoAdvance) return;
        if (i < pages.length - 1) { changePage(1); speakPage(i+1); } else { speakText('Sempre único, sempre seu.'); }
      });
    };
    const changePage = offset => {
      const np = currentPage + offset; if (np<0||np>=pages.length) return;
      pages[currentPage].classList.remove('active'); pages[np].classList.add('active');
      currentPage = np; document.getElementById('pageIndicator').textContent = `${currentPage+1} / ${pages.length}`;
    };
    const showLoading = msg => {
      const respEl = document.getElementById('response');
      const controls = respEl.querySelector('.response-controls');
      respEl.querySelectorAll('.page:not(.initial)').forEach(p=>p.remove());
      const page = createEl('div','page active'); page.appendChild(createEl('p','footer-text',msg));
      respEl.insertBefore(page, controls); pages = [page]; currentPage = 0; document.getElementById('pageIndicator').textContent = '…';
    };

    async function callAI() {
      apiKey = localStorage.getItem('di_apiKey') || apiKey;

      if (!apiKey) {
        alert('Nenhuma API Key ativa! Ative uma chave no Card (Cofre) ou no Painel.');
        return;
      }
      const bodyObj = { model: modelName, messages: conversation.slice(), temperature: TEMPERATURE };
      const messagesToSend = [];
      if (assistantEnabled && trainingActive && training) messagesToSend.push({ role:'system', content: training });
      conversation.forEach(m => { if (m.role !== 'system') messagesToSend.push(m); });
      bodyObj.messages = messagesToSend;

      try {
        const resp = await fetch(API_ENDPOINT, {
          method:'POST', headers:{ 'Authorization':`Bearer ${apiKey}`, 'Content-Type':'application/json' },
          body: JSON.stringify(bodyObj)
        });
        if (!resp.ok) throw new Error('Erro API: ' + resp.status);
        const data = await resp.json();
        const answer = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ? data.choices[0].message.content.trim() : 'Resposta vazia';
        conversation.push({ role:'assistant', content: answer });
        renderPaginatedResponse(answer);
      } catch (err) {
        console.error(err);
        const errorMsg = 'Falha na conexão. Verifique se a chave está ativa no Card.';
        conversation.push({ role:'assistant', content: errorMsg });
        renderPaginatedResponse(errorMsg);
      }
    }

    async function sendMessage(){
      const respEl = document.getElementById('response');
      const initPage = respEl.querySelector('.page.initial');
      if (initPage) initPage.remove();
      const input = document.getElementById('userInput');
      const raw = input.value.trim(); if (!raw) return;
      input.value = '';
      speechSynthesis.cancel(); speakText('');

      if (raw.toLowerCase().includes('oi dual')) {
        assistantEnabled = true; localStorage.setItem('di_assistantEnabled','1');
        updateToggleBtnVisual();
        showLoading('Conectando Dual Infodose...');
        if (training && trainingActive) conversation.unshift({ role:'system', content: training });
      } else { showLoading('Processando...'); }
      conversation.push({ role:'user', content: raw });
      callAI();
    }
    
    // Quick Toggle Action
    els.toggleBtn.addEventListener('click', () => {
        assistantEnabled = !assistantEnabled;
        localStorage.setItem('di_assistantEnabled', assistantEnabled ? '1' : '0');
        showToaster(assistantEnabled ? 'Assistant ON (Fetch Ativo)' : 'Assistant OFF (Fetch Desativado)', assistantEnabled ? 'success' : 'default');
        updateChatUI();
    });

    function cristalizar({ title, content }) {
      const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
      list.unshift({ id: Date.now(), title, content, user: userName, infodose: infodoseName, at: new Date().toISOString() });
      localStorage.setItem(CRYSTAL_KEY, JSON.stringify(list)); refreshCrystalList();
    }
    function refreshCrystalList() {
      const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY) || '[]');
      const el = document.getElementById('crystalList'); el.innerHTML = '';
      if (!list.length) { el.innerHTML = '<div class="small">Vazio.</div>'; return; }
      list.forEach(it => {
        const row = createEl('div','crystal-item');
        const left = createEl('div','','<strong>'+it.title+'</strong><div class="small">'+(it.infodose||'')+'</div><div style="margin-top:4px;font-size:0.8em">'+it.content.slice(0,100)+'...</div>');
        const actions = createEl('div','actions');
        const copyBtn = createEl('button','btn btn-sec','Copy'); copyBtn.onclick=()=>navigator.clipboard.writeText(it.content);
        const delBtn = createEl('button','btn btn-sec','Del'); delBtn.onclick=()=>{ 
            const arr=JSON.parse(localStorage.getItem(CRYSTAL_KEY)||'[]'); 
            localStorage.setItem(CRYSTAL_KEY, JSON.stringify(arr.filter(x=>x.id!==it.id))); refreshCrystalList(); 
        };
        actions.append(copyBtn, delBtn); row.append(left, actions); el.appendChild(row);
      });
    }

    // --- SETUP CHAT UI EVENTS ---
    document.addEventListener('DOMContentLoaded', async () => {
      speechSynthesis.onvoiceschanged = () => { window._vozes = speechSynthesis.getVoices(); };

      try {
        particlesJS('particles-js',{ particles:{ number:{value:24},color:{value:['#0ff','#f0f']}, shape:{type:'circle'},opacity:{value:0.4},size:{value:2.4}, move:{enable:true,speed:1.5} }, retina_detect:true });
      } catch(e) { console.warn('particlesJS init failed', e); }

      document.getElementById('sendBtn').addEventListener('click', sendMessage);
      document.getElementById('userInput').addEventListener('keypress', e => { if (e.key==='Enter') sendMessage(); });
      document.querySelector('[data-action="prev"]').addEventListener('click', () => changePage(-1));
      document.querySelector('[data-action="next"]').addEventListener('click', () => changePage(1));

      document.getElementById('saveSystemBtn').addEventListener('click', () => {
         infodoseName = document.getElementById('infodoseNameInput').value.trim();
         assistantEnabled = document.getElementById('assistantActiveCheckbox').checked;
         trainingActive = document.getElementById('trainingActiveCheckbox').checked;
         
         const newKey = document.getElementById('apiKeyInput').value.trim();
         const newModel = document.getElementById('modelInput').value.trim();
         
         if(newKey) {
             apiKey = newKey;
             localStorage.setItem('di_apiKey', apiKey);
             if(typeof STATE !== 'undefined') {
                 const active = STATE.keys.find(k=>k.active);
                 if(active) { active.token = newKey; saveData(); }
             }
         }
         
         modelName = newModel || modelName;
         localStorage.setItem('di_modelName', modelName);

         const zen = document.getElementById('zenModeCheckbox').checked;
         if(zen) { 
             document.body.classList.add('zen-mode');
             document.getElementById('mantra-toggle').classList.add('collapsed');
         } else {
             document.body.classList.remove('zen-mode');
             document.getElementById('mantra-toggle').classList.remove('collapsed');
         }
         saveUIState(); 

         localStorage.setItem('di_infodoseName', infodoseName);
         localStorage.setItem('di_assistantEnabled', assistantEnabled?'1':'0'); localStorage.setItem('di_trainingActive', trainingActive?'1':'0');
         
         updateChatUI();
         toggleSection('systemCard', false);
         showToaster('Configurações Salvas', 'success');
      });

      // Crystal
      document.getElementById('crystalBtn').addEventListener('click', ()=>{ refreshCrystalList(); document.getElementById('crystalModal').classList.add('active'); });
      document.getElementById('closeCrystal').addEventListener('click', ()=>document.getElementById('crystalModal').classList.remove('active'));
      document.getElementById('exportAllCrystal').addEventListener('click', ()=>{
          const list = JSON.parse(localStorage.getItem(CRYSTAL_KEY)||'[]');
          if(!list.length) return alert('Nada.');
          const b = new Blob([JSON.stringify(list,null,2)], {type:'application/json'});
          const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download='crystals.json'; a.click();
      });
      document.getElementById('clearAllCrystal').addEventListener('click', ()=>{ localStorage.removeItem(CRYSTAL_KEY); refreshCrystalList(); });

      updateChatUI();

      // --- ADDED: missing button handlers ---
      function getAllResponseText() {
        const blocks = Array.from(document.querySelectorAll('.response-block p')).map(p=>p.innerText.trim()).filter(Boolean);
        if(blocks.length) return blocks.join('\n\n');
        const resp = document.getElementById('response');
        return resp ? resp.innerText.trim() : '';
      }
      const copyBtn = document.querySelector('.control-btn.copy-button');
      if (copyBtn) copyBtn.addEventListener('click', async () => {
        try {
          const text = getAllResponseText();
          await navigator.clipboard.writeText(text);
          showToaster('Texto copiado', 'success');
        } catch (e) { showToaster('Falha ao copiar', 'error'); console.error(e); }
      });
      const pasteBtn = document.querySelector('.control-btn.paste-button');
      if (pasteBtn) pasteBtn.addEventListener('click', async () => {
        try {
          const txt = await navigator.clipboard.readText();
          const ui = document.getElementById('userInput');
          if (ui) { ui.value = txt; ui.focus(); showToaster('Conteúdo colado no campo', 'success'); }
        } catch (e) { showToaster('Falha ao colar (permissão negada?)', 'error'); console.error(e); }
      });
      const copyAct = document.getElementById('copyActBtn');
      if (copyAct) copyAct.addEventListener('click', async () => {
        try {
          const txt = document.getElementById('actPre').innerText;
          await navigator.clipboard.writeText(txt);
          showToaster('Ativação copiada', 'success');
        } catch(e){ showToaster('Erro ao copiar ativação', 'error'); console.error(e); }
      });
      const downloadAct = document.getElementById('downloadActBtn');
      if (downloadAct) downloadAct.addEventListener('click', async () => {
        try {
          const node = document.getElementById('actPre');
          const canvas = await html2canvas(node, { backgroundColor: null, scale: 2 });
          canvas.toBlob(blob => {
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'ativacao.png'; a.click();
            URL.revokeObjectURL(a.href);
          });
        } catch(e){ showToaster('Erro ao gerar PNG', 'error'); console.error(e); }
      });

      // Training import/export
      const trainingInput = document.getElementById('trainingUpload');
      const exportTrainingBtn = document.getElementById('exportTrainingBtn');
      const trainingNameEl = document.getElementById('trainingFileName');

      if (trainingInput) {
        trainingInput.addEventListener('change', async (ev) => {
          const f = ev.target.files && ev.target.files[0];
          if (!f) return;
          const txt = await f.text();
          training = txt;
          trainingFileName = f.name;
          localStorage.setItem('di_trainingText', training);
          localStorage.setItem('di_trainingFileName', trainingFileName);
          if (trainingNameEl) trainingNameEl.innerText = trainingFileName;
          showToaster('Treinamento importado', 'success');
        });
      }
      if (exportTrainingBtn) {
        exportTrainingBtn.addEventListener('click', () => {
          if (!training) { showToaster('Nenhum treinamento para exportar', 'error'); return; }
          const b = new Blob([training], { type: 'text/plain' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = (trainingFileName||'training.txt'); a.click();
        });
      }

      // Keys export/import
      const exportKeysBtn = document.getElementById('exportKeysBtn');
      const importKeysBtn = document.getElementById('importKeysBtn');
      const importFileInput = document.getElementById('importFileInput');

      if (exportKeysBtn) exportKeysBtn.addEventListener('click', () => {
        const b = new Blob([JSON.stringify(STATE.keys || [], null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'keys.json'; a.click();
      });
      if (importKeysBtn && importFileInput) {
        importKeysBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', async (ev) => {
          const f = ev.target.files && ev.target.files[0];
          if (!f) return;
          try {
            const txt = await f.text();
            const parsed = JSON.parse(txt);
            if (!Array.isArray(parsed)) throw new Error('Formato inválido');
            STATE.keys = parsed;
            saveData(); renderKeysList(); showToaster('Chaves importadas', 'success');
          } catch (e) { showToaster('Erro ao importar chaves', 'error'); console.error(e); }
        });
      }

    });

    // Mantra
    const mantraBtn = document.getElementById('mantra-toggle');
    const mantraText = document.getElementById('mantra-text');
    let mantraCollapsed = false;
    mantraBtn.addEventListener('click', () => {
      mantraCollapsed = !mantraCollapsed;
      if (mantraCollapsed) {
        mantraBtn.classList.add('collapsed'); document.body.classList.add('zen-mode');
        mantraText.classList.add('fade-out'); setTimeout(()=>{ mantraText.innerHTML = 'USE · TRANSFORME · DEVOLVA'; mantraText.classList.remove('fade-out'); },300);
      } else {
        mantraBtn.classList.remove('collapsed'); document.body.classList.remove('zen-mode');
        mantraText.classList.add('fade-out'); setTimeout(()=>{ mantraText.innerHTML = 'Do seu jeito. <strong>Sempre</strong> único. <strong>Sempre</strong> seu.'; mantraText.classList.remove('fade-out'); },300);
      }
    });
  </script>

<script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js')
        .then(() => console.log('Service Worker Registered'))
        .catch(e=>console.warn('SW register failed',e));
    }
  </script>






  <div class="dual-chat-module" id="dualChatModule" aria-live="polite">
    <div class="response-container" id="response" role="log" aria-atomic="false">
      <div class="pages-wrapper" id="pagesWrapper">
        <div class="page initial active" data-page-index="0">
          <strong id="bootText" class="pulse" data-text="🧬 Iniciando. Pulso simbiótico detectado. Presença reconhecida.">
            🧬 Iniciando. Pulso simbiótico detectado. Presença reconhecida.
          </strong>
        </div>
      </div>

      <p class="footer-text" id="footerHint" role="button" tabindex="0">
        <span class="footer-dot" aria-hidden="true"></span>
        Do seu jeito. Sempre único. Sempre seu.
      </p>

      <div class="response-controls" aria-hidden="false">
        <div class="control-buttons">
          <button class="icon-btn" id="copyBtn" type="button" title="Copiar resposta" aria-label="Copiar resposta">⧉</button>
          <button class="icon-btn" id="pasteBtn" type="button" title="Colar no input" aria-label="Colar do clipboard">⧠</button>
          <button class="icon-btn" id="toggleSettingsBtn" type="button" title="Configurar IA" aria-label="Abrir configurações">⚙</button>
        </div>
        <div class="pagination" role="navigation" aria-label="Paginação de respostas">
          <button id="pagePrev" type="button" aria-label="Página anterior">⟵</button>
          <span id="pageIndicator">1 / 1</span>
          <button id="pageNext" type="button" aria-label="Próxima página">⟶</button>
        </div>
      </div>

      <div id="iaConfigPanel" aria-hidden="true">
        <div id="iaConfigHeader">
          <span>Config IA · OpenRouter</span>
          <button type="button" class="ia-close-btn" id="closeIaConfigPanelBtn" aria-label="Fechar">✕</button>
        </div>
        <div class="ia-config-body">
          <div class="ia-field">
            <label for="apiKeyInput">API Key (sk-or-...)</label>
            <input id="apiKeyInput" type="password" placeholder="Cole sua chave OpenRouter aqui" autocomplete="off">
          </div>
          <div class="ia-field">
            <label for="modelSelect">Modelo</label>
            <select id="modelSelect">
              <option value="deepseek/deepseek-chat-v3-0324:free">deepseek-v3 · free</option>
              <option value="meta-llama/llama-3.1-70b-instruct:free">Llama 3.1 70B · free</option>
              <option value="openai/gpt-4.1-mini">GPT-4.1 mini</option>
              <option value="openai/gpt-4.1">GPT-4.1</option>
              <option value="custom">Custom (digitar abaixo)</option>
            </select>
          </div>
          <div class="ia-field">
            <label for="customModelInput">Modelo custom (opcional)</label>
            <input id="customModelInput" type="text" placeholder="ex: openai/gpt-4.1-mini">
          </div>
          <div class="ia-actions">
            <button class="pill-btn" id="saveIaConfigBtn" type="button">Salvar</button>
            <button class="pill-btn secondary" id="clearIaConfigBtn" type="button">Limpar</button>
          </div>
          <div class="ia-status" id="iaStatus">Nenhuma chave salva ainda.</div>
        </div>
      </div>
    </div>

    <div class="input-container" role="form" aria-label="Entrada de mensagem">
      <input id="userInput" type="text" placeholder="Diga: 'oi, Dual'." aria-label="Digite sua mensagem">
      <button id="sendBtn" type="button" title="Enviar" aria-label="Enviar mensagem">➤</button>
      <button id="voiceBtn" type="button" title="Falar" aria-label="Ativar reconhecimento de voz">🔘</button>
    </div>
  </div>

  <script>
    (function(){
      let didInit = false;

      const STORAGE = {
        OPENROUTER_KEY: 'hub1.dual.openrouter_key',
        OPENROUTER_MODEL: 'hub1.dual.openrouter_model'
      };

      const DEFAULTS = {
        API_URL: 'https://openrouter.ai/api/v1/chat/completions',
        MODEL:   'deepseek/deepseek-chat-v3-0324:free',
        TEMP:    0.2
      };

      let CONFIG = {
        API_URL: DEFAULTS.API_URL,
        MODEL: DEFAULTS.MODEL,
        TEMP:  DEFAULTS.TEMP,
        AUTH_TOKEN: ''
      };

      const $  = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      const moduleRoot     = $('#dualChatModule');
      const responseContainer = $('#response');
      const pagesWrapper   = $('#pagesWrapper');
      const footerHint     = $('#footerHint');
      const copyBtn        = $('#copyBtn');
      const pasteBtn       = $('#pasteBtn');
      const toggleSettingsBtn = $('#toggleSettingsBtn');
      const iaConfigPanel  = $('#iaConfigPanel');
      const closeIaConfigPanelBtn = $('#closeIaConfigPanelBtn');
      const apiKeyInput    = $('#apiKeyInput');
      const modelSelect    = $('#modelSelect');
      const customModelInput = $('#customModelInput');
      const saveIaConfigBtn  = $('#saveIaConfigBtn');
      const clearIaConfigBtn = $('#clearIaConfigBtn');
      const iaStatus       = $('#iaStatus');
      const pagePrev       = $('#pagePrev');
      const pageNext       = $('#pageNext');
      const pageIndicator  = $('#pageIndicator');
      const userInput      = $('#userInput');
      const sendBtn        = $('#sendBtn');
      const voiceBtn       = $('#voiceBtn');

      let pages = [];
      let currentPage = 0;
      let isCollapsed = false;
      let conversation = [];
      let recognition = null;
      let isRecording = false;
      let interimTimer = null;

      function emitToHost(type, payload){
        try {
          window.parent?.postMessage({ source: 'hub1.dual.infodose', type, payload }, '*');
        }catch(e){}
      }

      // ===== Livro Vivo parser (auto) =====
      function parseMarkdownBasic(text){
        if (!text) return '';
        let out = text;
        out = out.replace(/^### (.*)$/gim, '<h3>$1</h3>');
        out = out.replace(/^## (.*)$/gim, '<h2>$1</h2>');
        out = out.replace(/^# (.*)$/gim, '<h1>$1</h1>');
        out = out.replace(/^> (.*)$/gim, '<blockquote>$1</blockquote>');
        out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
        out = out.replace(/^\s*[-*+] (.*)$/gim, '<li>$1</li>');
        out = out.replace(/(<li>.*<\/li>)/gims, '<ul>$1</ul>');
        return out;
      }

      function parseLivroVivo(text){
        if (!text) return '';
        let out = text;
        out = out.replace(/^::(info|warn|success|question|aside)\s+(.*)$/gim,
          function(_m, type, rest){
            return '<div class="lv-callout ' + type + '">' + rest + '</div>';
          });
        out = parseMarkdownBasic(out);
        return out.replace(/\n/g, '<br/>');
      }

      function buildCinematicBlocks(text){
        const parts = text.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);
        if (!parts.length){
          return [{
            kind:'middle',
            html:'<p>' + parseLivroVivo(text) + '</p>'
          }];
        }
        const blocks = parts.map((p,idx) => {
          const kind = idx === 0 ? 'intro' : (idx === parts.length - 1 ? 'ending' : 'middle');
          const html = parseLivroVivo(p);
          return { kind, html };
        });
        return blocks.slice(0,3);
      }

      // ===== IA config =====
      function loadIaConfig(){
        const key   = localStorage.getItem(STORAGE.OPENROUTER_KEY) || '';
        const model = localStorage.getItem(STORAGE.OPENROUTER_MODEL) || DEFAULTS.MODEL;

        CONFIG.API_URL = DEFAULTS.API_URL;
        CONFIG.MODEL   = model || DEFAULTS.MODEL;
        CONFIG.TEMP    = DEFAULTS.TEMP;
        CONFIG.AUTH_TOKEN = key ? 'Bearer ' + key : '';

        apiKeyInput.value = key;
        let found = false;
        Array.from(modelSelect.options).forEach(opt => {
          if (opt.value === model){ found = true; modelSelect.value = model; }
        });
        if (!found){
          modelSelect.value = 'custom';
          customModelInput.value = model;
        }

        if (!key){
          iaStatus.textContent = 'Nenhuma chave salva ainda.';
          iaStatus.className = 'ia-status warn';
          iaConfigPanel.setAttribute('aria-hidden','false');
        } else {
          iaStatus.textContent = 'Config carregada. Pronto para chamar a IA.';
          iaStatus.className = 'ia-status ok';
          iaConfigPanel.setAttribute('aria-hidden','true');
        }
      }

      function saveIaConfig(){
        let key = apiKeyInput.value.trim();
        let model = modelSelect.value;
        if (model === 'custom'){
          const c = customModelInput.value.trim();
          if (c) model = c;
        }
        if (!model) model = DEFAULTS.MODEL;

        if (!key){
          iaStatus.textContent = 'Cole uma chave sk-or-... para salvar.';
          iaStatus.className = 'ia-status warn';
          return;
        }

        try{
          localStorage.setItem(STORAGE.OPENROUTER_KEY, key);
          localStorage.setItem(STORAGE.OPENROUTER_MODEL, model);
        }catch(e){ console.error(e); }

        CONFIG.AUTH_TOKEN = 'Bearer ' + key;
        CONFIG.MODEL = model;
        iaStatus.textContent = 'Config salva com sucesso.';
        iaStatus.className = 'ia-status ok';
        emitToHost('hub1.dual.configSaved', { model: CONFIG.MODEL });
      }

      function clearIaConfig(){
        try{
          localStorage.removeItem(STORAGE.OPENROUTER_KEY);
          localStorage.removeItem(STORAGE.OPENROUTER_MODEL);
        }catch(e){ console.error(e); }
        apiKeyInput.value = '';
        customModelInput.value = '';
        modelSelect.value = DEFAULTS.MODEL;
        CONFIG.AUTH_TOKEN = '';
        CONFIG.MODEL = DEFAULTS.MODEL;
        iaStatus.textContent = 'Config limpa. Defina novamente antes de enviar.';
        iaStatus.className = 'ia-status warn';
        emitToHost('hub1.dual.configCleared', {});
      }

      // ===== Páginas =====
      function updatePageIndicator(){
        const total = pages.length || 1;
        const current = Math.min(currentPage + 1, total);
        pageIndicator.textContent = current + ' / ' + total;
      }

      function showPage(idx){
        const list = $$('.page');
        list.forEach(p => p.classList.remove('active'));
        const target = list[idx];
        if (target){
          target.classList.add('active');
          currentPage = idx;
          // ensure active page block is visible
          const block = target.querySelector('.response-block');
          if (block && typeof block.scrollIntoView === 'function'){
            try { block.scrollIntoView({ behavior:'smooth', block:'center' }); }catch(e){}
          }
        }
        updatePageIndicator();
      }

      function renderPagesFromData(data){
        // defensive: cap number of pages to avoid UI overload
        const CAP = 50;
        const clipped = Array.isArray(data) ? data.slice(0, CAP) : [];
        const existing = $$('.page');
        existing.forEach(p => p.remove());

        clipped.forEach((page,idx) => {
          const div = document.createElement('div');
          div.className = 'page' + (idx === 0 ? ' active' : '');
          div.dataset.pageIndex = String(idx);

          const block = document.createElement('div');
          block.className = 'response-block ' + (page.kind || 'middle');
          block.innerHTML = page.html;

          div.appendChild(block);
          pagesWrapper.appendChild(div);
        });

        pages = clipped.slice();
        currentPage = 0;
        updatePageIndicator();

        // bring container to top and ensure first page visible
        try { responseContainer.scrollTo({ top: 0, behavior: 'smooth' }); }catch(e){ responseContainer.scrollTop = 0; }
        showPage(0);

        emitToHost('hub1.dual.rendered', { pages: pages });
      }

      pagePrev.addEventListener('click', () => {
        if (pages.length <= 1) return;
        const next = (currentPage - 1 + pages.length) % pages.length;
        showPage(next);
      });
      pageNext.addEventListener('click', () => {
        if (pages.length <= 1) return;
        const next = (currentPage + 1) % pages.length;
        showPage(next);
      });

      // ===== Colapso =====
      function setCollapsed(state){
        isCollapsed = state;
        if (isCollapsed){
          moduleRoot.classList.add('collapsed');
        } else {
          moduleRoot.classList.remove('collapsed');
        }
        emitToHost('hub1.dual.collapsed', { collapsed: isCollapsed });
      }

      footerHint.addEventListener('click', () => {
        setCollapsed(!isCollapsed);
      });
      footerHint.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          setCollapsed(!isCollapsed);
        }
      });

      // ===== IA call =====
      async function callOpenRouter(promptText){
        if (!CONFIG.AUTH_TOKEN){
          throw new Error('Defina a chave OpenRouter no painel de Config IA.');
        }

        const messages = [
          {
            role:'system',
            content:
`Você é Dual.Infodose, assistente cinematográfico.
Responda em português, usando blocos que possam virar "Livro Vivo" (Markdown + callouts ::info, ::warn, ::success, ::question, ::aside, listas, títulos).
Estruture a resposta em:
1) Recompensa inicial,
2) Curiosidade no meio,
3) Convite final.`
          },
          { role:'user', content: promptText }
        ];

        const body = {
          model: CONFIG.MODEL,
          temperature: CONFIG.TEMP,
          messages
        };

        const res = await fetch(CONFIG.API_URL, {
          method:'POST',
          headers:{
            'Content-Type':'application/json',
            'Authorization': CONFIG.AUTH_TOKEN
          },
          body: JSON.stringify(body)
        });

        if (!res.ok){
          const txt = await res.text().catch(()=> '');
          console.error('Erro IA', res.status, txt);
          if (res.status === 401 || res.status === 403) {
            throw new Error('Erro de autenticação: verifique sua chave OpenRouter (401/403).');
          }
          throw new Error('Falha na resposta da IA: ' + res.status + ' — ' + (txt || 'sem texto'));
        }

        const data = await res.json();
        const choice = data.choices && data.choices[0];
        const content = choice?.message?.content || '(sem conteúdo retornado)';
        conversation.push({ role:'user', content: promptText });
        conversation.push({ role:'assistant', content });
        return content;
      }

      // ===== Mic =====
      function initSpeechRecognition(){
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) return null;
        const r = new SR();
        r.lang = 'pt-BR';
        r.continuous = false; // prefer one-shot per click
        r.interimResults = true; // allow partial transcripts
        r.maxAlternatives = 1;
        return r;
      }

      function setupVoiceBtn(){
        recognition = initSpeechRecognition();
        if (!recognition){
          voiceBtn.addEventListener('click', () => {
            try{ alert('Reconhecimento de voz não suportado neste navegador. Teste no Chrome/Edge.'); }catch(e){}
          });
          return;
        }

        // handle partial and final results
        recognition.onresult = (ev) => {
          // combine interim and final results; keep previous content only if adding to existing input
          let interim = '';
          let finalText = '';
          for (let i = ev.resultIndex; i < ev.results.length; i++){
            const r = ev.results[i];
            const t = r[0]?.transcript || '';
            if (r.isFinal) finalText += t + ' ';
            else interim += t + ' ';
          }
          // if we have final text, append it and clear interim
          if (finalText.trim()){
            // append final result to existing userInput (maintain previous typed text)
            userInput.value = (userInput.value ? userInput.value + ' ' : '') + finalText.trim();
            // after final result, auto-stop recognition to detect end-of-speech
            try { recognition.stop(); }catch(e){}
          } else {
            // just show interim in the input (do not overwrite finalized typed content)
            const base = (userInput.value && userInput.value.trim()) ? userInput.value.trim() : '';
            // show interim separately without permanently changing typed content (we'll set value but not commit)
            userInput.value = (base ? base + ' ' : '') + interim.trim();
          }
        };

        recognition.onspeechstart = () => {
          isRecording = true;
          voiceBtn.classList.add('recording');
        };

        recognition.onspeechend = () => {
          // when speech ends, we try to stop the recognition gracefully;
          try { recognition.stop(); }catch(e){}
        };

        recognition.onerror = (ev) => {
          console.error('SpeechRecognition error', ev.error);
          isRecording = false;
          voiceBtn.classList.remove('recording');
        };

        recognition.onend = () => {
          isRecording = false;
          voiceBtn.classList.remove('recording');
        };

        voiceBtn.addEventListener('click', () => {
          if (!recognition) return;
          if (!isRecording){
            try {
              recognition.start();
              isRecording = true;
              voiceBtn.classList.add('recording');
            }catch(e){ console.error(e); }
          } else {
            try { recognition.stop(); }catch(e){ console.error(e); }
          }
        });
      }

      // ===== Send =====
      async function handleSend(){
        const text = userInput.value.trim();
        if (!text) return;

        setCollapsed(false);

        const oldFooter = footerHint.textContent;
        userInput.value = '';
        userInput.disabled = true;
        sendBtn.disabled = true;
        footerHint.textContent = 'Processando pulso...';
        emitToHost('hub1.dual.sent', { text });

        try{
          const answer = await callOpenRouter(text);
          const cinematicBlocks = buildCinematicBlocks(answer);
          renderPagesFromData(cinematicBlocks);
          emitToHost('hub1.dual.response', { text: answer, cinematicBlocks });
        }catch(err){
          console.error(err);
          const fallback = [{
            kind:'ending',
            html:'<p><strong>Ops.</strong> Não consegui falar com o OpenRouter agora. Verifique sua chave e tente de novo.</p>'
          }];
          renderPagesFromData(fallback);
          emitToHost('hub1.dual.error', { message: (err && err.message) || 'Erro na chamada IA' });
        }finally{
          userInput.disabled = false;
          sendBtn.disabled = false;
          footerHint.textContent = oldFooter;
          userInput.focus();
        }
      }

      sendBtn.addEventListener('click', handleSend);
      userInput.addEventListener('keydown', ev => {
        if (ev.key === 'Enter' && !ev.shiftKey){
          ev.preventDefault();
          handleSend();
        }
      });

      // Copy / Paste improved
      copyBtn.addEventListener('click', async () => {
        const activePageNode = $$('.page')[currentPage];
        if (!activePageNode) return;
        const block = activePageNode.querySelector('.response-block');
        if (!block) return;
        const text = block.innerText || block.textContent || '';
        try{
          if (navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(text);
          } else {
            // fallback
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            ta.remove();
          }
          footerHint.textContent = 'Resposta copiada.';
          emitToHost('hub1.dual.copied', { text });
          setTimeout(()=> footerHint.textContent = 'Do seu jeito. Sempre único. Sempre seu.', 1400);
        }catch(e){
          console.error('Clipboard copy failed', e);
          footerHint.textContent = 'Não consegui copiar automaticamente.';
          setTimeout(()=> footerHint.textContent = 'Do seu jeito. Sempre único. Sempre seu.', 1400);
        }
      });

      pasteBtn.addEventListener('click', async () => {
        try{
          let txt = '';
          if (navigator.clipboard && navigator.clipboard.readText){
            txt = await navigator.clipboard.readText();
          } else {
            // no reliable API -> nothing to do
          }
          if (txt) userInput.value = txt;
        }catch(e){
          console.error('Falha ao ler clipboard', e);
        }
      });

      // Painel IA open/close
      toggleSettingsBtn.addEventListener('click', () => {
        iaConfigPanel.classList.toggle('active');
        const visible = iaConfigPanel.classList.contains('active');
        iaConfigPanel.setAttribute('aria-hidden', visible ? 'false' : 'true');
        emitToHost('hub1.dual.settingsToggled', { open: visible });
      });
      closeIaConfigPanelBtn.addEventListener('click', () => {
        iaConfigPanel.classList.remove('active');
        iaConfigPanel.setAttribute('aria-hidden','true');
      });

      if (saveIaConfigBtn) saveIaConfigBtn.addEventListener('click', saveIaConfig);
      if (clearIaConfigBtn) clearIaConfigBtn.addEventListener('click', clearIaConfig);

      // ===== Visual viewport keyboard adjustments =====
      function adjustForViewportKeyboard(){
        if (!moduleRoot) return;
        if (!window.visualViewport) return;
        const baseBottom = 69;
        function recalc(){
          const inset = Math.max(0, Math.round(window.innerHeight - window.visualViewport.height));
          try{
            moduleRoot.style.bottom = `calc(${baseBottom}px + ${inset}px + env(safe-area-inset-bottom))`;
          }catch(e){
            moduleRoot.style.bottom = (baseBottom + inset) + 'px';
          }
        }
        window.visualViewport.addEventListener('resize', recalc);
        window.visualViewport.addEventListener('scroll', recalc);
        recalc();
      }

      // ===== Messaging from host =====
      window.addEventListener('message', (ev) => {
        const data = ev.data || {};
        if (!data || data.source !== 'hub1.host') return;
        const { type, payload } = data || {};
        if (type === 'hub1.dual.setToken'){
          if (payload && payload.token){
            CONFIG.AUTH_TOKEN = 'Bearer ' + payload.token;
            try { localStorage.setItem(STORAGE.OPENROUTER_KEY, payload.token); }catch(e){}
            loadIaConfig();
          }
        }
        if (type === 'hub1.dual.restore'){
          if (payload && Array.isArray(payload.pages)){
            renderPagesFromData(payload.pages);
          }
        }
        if (type === 'hub1.dual.setModel'){
          if (payload && payload.model){
            CONFIG.MODEL = payload.model;
            try { localStorage.setItem(STORAGE.OPENROUTER_MODEL, payload.model); }catch(e){}
            loadIaConfig();
          }
        }
      }, false);

      function init(){
        if (didInit) return;
        didInit = true;
        loadIaConfig();
        updatePageIndicator();
        setCollapsed(false);
        setupVoiceBtn();
        adjustForViewportKeyboard();
        // expose simple API
        window.Hub1DualInfodose = {
          sendText: async (txt) => {
            userInput.value = txt;
            await handleSend();
          },
          setToken: (token) => {
            CONFIG.AUTH_TOKEN = 'Bearer ' + token;
            try { localStorage.setItem(STORAGE.OPENROUTER_KEY, token); }catch(e){}
            loadIaConfig();
          },
          restorePages: (pages) => {
            renderPagesFromData(pages);
          }
        };
      }

      document.addEventListener('DOMContentLoaded', init);
      if (document.readyState === 'complete' || document.readyState === 'interactive'){
        init();
      }
    })();
  </script>

<script>
    (function(){
      let didInit = false;

      const STORAGE = {
        OPENROUTER_KEY: 'hub1.dual.openrouter_key',
        OPENROUTER_MODEL: 'hub1.dual.openrouter_model'
      };

      const DEFAULTS = {
        API_URL: 'https://openrouter.ai/api/v1/chat/completions',
        MODEL:   'deepseek/deepseek-chat-v3-0324:free',
        TEMP:    0.2
      };

      let CONFIG = {
        API_URL: DEFAULTS.API_URL,
        MODEL: DEFAULTS.MODEL,
        TEMP:  DEFAULTS.TEMP,
        AUTH_TOKEN: ''
      };

      const $  = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      const moduleRoot     = $('#dualChatModule');
      const responseContainer = $('#response');
      const pagesWrapper   = $('#pagesWrapper');
      const footerHint     = $('#footerHint');
      const copyBtn        = $('#copyBtn');
      const pasteBtn       = $('#pasteBtn');
      const toggleSettingsBtn = $('#toggleSettingsBtn');
      const iaConfigPanel  = $('#iaConfigPanel');
      const closeIaConfigPanelBtn = $('#closeIaConfigPanelBtn');
      const apiKeyInput    = $('#apiKeyInput');
      const modelSelect    = $('#modelSelect');
      const customModelInput = $('#customModelInput');
      const saveIaConfigBtn  = $('#saveIaConfigBtn');
      const clearIaConfigBtn = $('#clearIaConfigBtn');
      const iaStatus       = $('#iaStatus');
      const pagePrev       = $('#pagePrev');
      const pageNext       = $('#pageNext');
      const pageIndicator  = $('#pageIndicator');
      const userInput      = $('#userInput');
      const sendBtn        = $('#sendBtn');
      const voiceBtn       = $('#voiceBtn');

      let pages = [];
      let currentPage = 0;
      let isCollapsed = false;
      let conversation = [];
      let recognition = null;
      let isRecording = false;
      let interimTimer = null;

      function emitToHost(type, payload){
        try {
          window.parent?.postMessage({ source: 'hub1.dual.infodose', type, payload }, '*');
        }catch(e){}
      }

      // ===== Livro Vivo parser (auto) =====
      function parseMarkdownBasic(text){
        if (!text) return '';
        let out = text;
        out = out.replace(/^### (.*)$/gim, '<h3>$1</h3>');
        out = out.replace(/^## (.*)$/gim, '<h2>$1</h2>');
        out = out.replace(/^# (.*)$/gim, '<h1>$1</h1>');
        out = out.replace(/^> (.*)$/gim, '<blockquote>$1</blockquote>');
        out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
        out = out.replace(/^\s*[-*+] (.*)$/gim, '<li>$1</li>');
        out = out.replace(/(<li>.*<\/li>)/gims, '<ul>$1</ul>');
        return out;
      }

      function parseLivroVivo(text){
        if (!text) return '';
        let out = text;
        out = out.replace(/^::(info|warn|success|question|aside)\s+(.*)$/gim,
          function(_m, type, rest){
            return '<div class="lv-callout ' + type + '">' + rest + '</div>';
          });
        out = parseMarkdownBasic(out);
        return out.replace(/\n/g, '<br/>');
      }

      function buildCinematicBlocks(text){
        const parts = text.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);
        if (!parts.length){
          return [{
            kind:'middle',
            html:'<p>' + parseLivroVivo(text) + '</p>'
          }];
        }
        const blocks = parts.map((p,idx) => {
          const kind = idx === 0 ? 'intro' : (idx === parts.length - 1 ? 'ending' : 'middle');
          const html = parseLivroVivo(p);
          return { kind, html };
        });
        return blocks.slice(0,3);
      }

      // ===== IA config =====
      function loadIaConfig(){
        const key   = localStorage.getItem(STORAGE.OPENROUTER_KEY) || '';
        const model = localStorage.getItem(STORAGE.OPENROUTER_MODEL) || DEFAULTS.MODEL;

        CONFIG.API_URL = DEFAULTS.API_URL;
        CONFIG.MODEL   = model || DEFAULTS.MODEL;
        CONFIG.TEMP    = DEFAULTS.TEMP;
        CONFIG.AUTH_TOKEN = key ? 'Bearer ' + key : '';

        apiKeyInput.value = key;
        let found = false;
        Array.from(modelSelect.options).forEach(opt => {
          if (opt.value === model){ found = true; modelSelect.value = model; }
        });
        if (!found){
          modelSelect.value = 'custom';
          customModelInput.value = model;
        }

        if (!key){
          iaStatus.textContent = 'Nenhuma chave salva ainda.';
          iaStatus.className = 'ia-status warn';
          iaConfigPanel.setAttribute('aria-hidden','false');
        } else {
          iaStatus.textContent = 'Config carregada. Pronto para chamar a IA.';
          iaStatus.className = 'ia-status ok';
          iaConfigPanel.setAttribute('aria-hidden','true');
        }
      }

      function saveIaConfig(){
        let key = apiKeyInput.value.trim();
        let model = modelSelect.value;
        if (model === 'custom'){
          const c = customModelInput.value.trim();
          if (c) model = c;
        }
        if (!model) model = DEFAULTS.MODEL;

        if (!key){
          iaStatus.textContent = 'Cole uma chave sk-or-... para salvar.';
          iaStatus.className = 'ia-status warn';
          return;
        }

        try{
          localStorage.setItem(STORAGE.OPENROUTER_KEY, key);
          localStorage.setItem(STORAGE.OPENROUTER_MODEL, model);
        }catch(e){ console.error(e); }

        CONFIG.AUTH_TOKEN = 'Bearer ' + key;
        CONFIG.MODEL = model;
        iaStatus.textContent = 'Config salva com sucesso.';
        iaStatus.className = 'ia-status ok';
        emitToHost('hub1.dual.configSaved', { model: CONFIG.MODEL });
      }

      function clearIaConfig(){
        try{
          localStorage.removeItem(STORAGE.OPENROUTER_KEY);
          localStorage.removeItem(STORAGE.OPENROUTER_MODEL);
        }catch(e){ console.error(e); }
        apiKeyInput.value = '';
        customModelInput.value = '';
        modelSelect.value = DEFAULTS.MODEL;
        CONFIG.AUTH_TOKEN = '';
        CONFIG.MODEL = DEFAULTS.MODEL;
        iaStatus.textContent = 'Config limpa. Defina novamente antes de enviar.';
        iaStatus.className = 'ia-status warn';
        emitToHost('hub1.dual.configCleared', {});
      }

      // ===== Páginas =====
      function updatePageIndicator(){
        const total = pages.length || 1;
        const current = Math.min(currentPage + 1, total);
        pageIndicator.textContent = current + ' / ' + total;
      }

      function showPage(idx){
        const list = $$('.page');
        list.forEach(p => p.classList.remove('active'));
        const target = list[idx];
        if (target){
          target.classList.add('active');
          currentPage = idx;
          // ensure active page block is visible
          const block = target.querySelector('.response-block');
          if (block && typeof block.scrollIntoView === 'function'){
            try { block.scrollIntoView({ behavior:'smooth', block:'center' }); }catch(e){}
          }
        }
        updatePageIndicator();
      }

      function renderPagesFromData(data){
        // defensive: cap number of pages to avoid UI overload
        const CAP = 50;
        const clipped = Array.isArray(data) ? data.slice(0, CAP) : [];
        const existing = $$('.page');
        existing.forEach(p => p.remove());

        clipped.forEach((page,idx) => {
          const div = document.createElement('div');
          div.className = 'page' + (idx === 0 ? ' active' : '');
          div.dataset.pageIndex = String(idx);

          const block = document.createElement('div');
          block.className = 'response-block ' + (page.kind || 'middle');
          block.innerHTML = page.html;

          div.appendChild(block);
          pagesWrapper.appendChild(div);
        });

        pages = clipped.slice();
        currentPage = 0;
        updatePageIndicator();

        // bring container to top and ensure first page visible
        try { responseContainer.scrollTo({ top: 0, behavior: 'smooth' }); }catch(e){ responseContainer.scrollTop = 0; }
        showPage(0);

        emitToHost('hub1.dual.rendered', { pages: pages });
      }

      pagePrev.addEventListener('click', () => {
        if (pages.length <= 1) return;
        const next = (currentPage - 1 + pages.length) % pages.length;
        showPage(next);
      });
      pageNext.addEventListener('click', () => {
        if (pages.length <= 1) return;
        const next = (currentPage + 1) % pages.length;
        showPage(next);
      });

      // ===== Colapso =====
      function setCollapsed(state){
        isCollapsed = state;
        if (isCollapsed){
          moduleRoot.classList.add('collapsed');
        } else {
          moduleRoot.classList.remove('collapsed');
        }
        emitToHost('hub1.dual.collapsed', { collapsed: isCollapsed });
      }

      footerHint.addEventListener('click', () => {
        setCollapsed(!isCollapsed);
      });
      footerHint.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          setCollapsed(!isCollapsed);
        }
      });

      // ===== IA call =====
      async function callOpenRouter(promptText){
        if (!CONFIG.AUTH_TOKEN){
          throw new Error('Defina a chave OpenRouter no painel de Config IA.');
        }

        const messages = [
          {
            role:'system',
            content:
`Você é Dual.Infodose, assistente cinematográfico.
Responda em português, usando blocos que possam virar "Livro Vivo" (Markdown + callouts ::info, ::warn, ::success, ::question, ::aside, listas, títulos).
Estruture a resposta em:
1) Recompensa inicial,
2) Curiosidade no meio,
3) Convite final.`
          },
          { role:'user', content: promptText }
        ];

        const body = {
          model: CONFIG.MODEL,
          temperature: CONFIG.TEMP,
          messages
        };

        const res = await fetch(CONFIG.API_URL, {
          method:'POST',
          headers:{
            'Content-Type':'application/json',
            'Authorization': CONFIG.AUTH_TOKEN
          },
          body: JSON.stringify(body)
        });

        if (!res.ok){
          const txt = await res.text().catch(()=> '');
          console.error('Erro IA', res.status, txt);
          if (res.status === 401 || res.status === 403) {
            throw new Error('Erro de autenticação: verifique sua chave OpenRouter (401/403).');
          }
          throw new Error('Falha na resposta da IA: ' + res.status + ' — ' + (txt || 'sem texto'));
        }

        const data = await res.json();
        const choice = data.choices && data.choices[0];
        const content = choice?.message?.content || '(sem conteúdo retornado)';
        conversation.push({ role:'user', content: promptText });
        conversation.push({ role:'assistant', content });
        return content;
      }

      // ===== Mic =====
      function initSpeechRecognition(){
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) return null;
        const r = new SR();
        r.lang = 'pt-BR';
        r.continuous = false; // prefer one-shot per click
        r.interimResults = true; // allow partial transcripts
        r.maxAlternatives = 1;
        return r;
      }

      function setupVoiceBtn(){
        recognition = initSpeechRecognition();
        if (!recognition){
          voiceBtn.addEventListener('click', () => {
            try{ alert('Reconhecimento de voz não suportado neste navegador. Teste no Chrome/Edge.'); }catch(e){}
          });
          return;
        }

        // handle partial and final results
        recognition.onresult = (ev) => {
          // combine interim and final results; keep previous content only if adding to existing input
          let interim = '';
          let finalText = '';
          for (let i = ev.resultIndex; i < ev.results.length; i++){
            const r = ev.results[i];
            const t = r[0]?.transcript || '';
            if (r.isFinal) finalText += t + ' ';
            else interim += t + ' ';
          }
          // if we have final text, append it and clear interim
          if (finalText.trim()){
            // append final result to existing userInput (maintain previous typed text)
            userInput.value = (userInput.value ? userInput.value + ' ' : '') + finalText.trim();
            // after final result, auto-stop recognition to detect end-of-speech
            try { recognition.stop(); }catch(e){}
          } else {
            // just show interim in the input (do not overwrite finalized typed content)
            const base = (userInput.value && userInput.value.trim()) ? userInput.value.trim() : '';
            // show interim separately without permanently changing typed content (we'll set value but not commit)
            userInput.value = (base ? base + ' ' : '') + interim.trim();
          }
        };

        recognition.onspeechstart = () => {
          isRecording = true;
          voiceBtn.classList.add('recording');
        };

        recognition.onspeechend = () => {
          // when speech ends, we try to stop the recognition gracefully;
          try { recognition.stop(); }catch(e){}
        };

        recognition.onerror = (ev) => {
          console.error('SpeechRecognition error', ev.error);
          isRecording = false;
          voiceBtn.classList.remove('recording');
        };

        recognition.onend = () => {
          isRecording = false;
          voiceBtn.classList.remove('recording');
        };

        voiceBtn.addEventListener('click', () => {
          if (!recognition) return;
          if (!isRecording){
            try {
              recognition.start();
              isRecording = true;
              voiceBtn.classList.add('recording');
            }catch(e){ console.error(e); }
          } else {
            try { recognition.stop(); }catch(e){ console.error(e); }
          }
        });
      }

      // ===== Send =====
      async function handleSend(){
        const text = userInput.value.trim();
        if (!text) return;

        setCollapsed(false);

        const oldFooter = footerHint.textContent;
        userInput.value = '';
        userInput.disabled = true;
        sendBtn.disabled = true;
        footerHint.textContent = 'Processando pulso...';
        emitToHost('hub1.dual.sent', { text });

        try{
          const answer = await callOpenRouter(text);
          const cinematicBlocks = buildCinematicBlocks(answer);
          renderPagesFromData(cinematicBlocks);
          emitToHost('hub1.dual.response', { text: answer, cinematicBlocks });
        }catch(err){
          console.error(err);
          const fallback = [{
            kind:'ending',
            html:'<p><strong>Ops.</strong> Não consegui falar com o OpenRouter agora. Verifique sua chave e tente de novo.</p>'
          }];
          renderPagesFromData(fallback);
          emitToHost('hub1.dual.error', { message: (err && err.message) || 'Erro na chamada IA' });
        }finally{
          userInput.disabled = false;
          sendBtn.disabled = false;
          footerHint.textContent = oldFooter;
          userInput.focus();
        }
      }

      sendBtn.addEventListener('click', handleSend);
      userInput.addEventListener('keydown', ev => {
        if (ev.key === 'Enter' && !ev.shiftKey){
          ev.preventDefault();
          handleSend();
        }
      });

      // Copy / Paste improved
      copyBtn.addEventListener('click', async () => {
        const activePageNode = $$('.page')[currentPage];
        if (!activePageNode) return;
        const block = activePageNode.querySelector('.response-block');
        if (!block) return;
        const text = block.innerText || block.textContent || '';
        try{
          if (navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(text);
          } else {
            // fallback
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            ta.remove();
          }
          footerHint.textContent = 'Resposta copiada.';
          emitToHost('hub1.dual.copied', { text });
          setTimeout(()=> footerHint.textContent = 'Do seu jeito. Sempre único. Sempre seu.', 1400);
        }catch(e){
          console.error('Clipboard copy failed', e);
          footerHint.textContent = 'Não consegui copiar automaticamente.';
          setTimeout(()=> footerHint.textContent = 'Do seu jeito. Sempre único. Sempre seu.', 1400);
        }
      });

      pasteBtn.addEventListener('click', async () => {
        try{
          let txt = '';
          if (navigator.clipboard && navigator.clipboard.readText){
            txt = await navigator.clipboard.readText();
          } else {
            // no reliable API -> nothing to do
          }
          if (txt) userInput.value = txt;
        }catch(e){
          console.error('Falha ao ler clipboard', e);
        }
      });

      // Painel IA open/close
      toggleSettingsBtn.addEventListener('click', () => {
        iaConfigPanel.classList.toggle('active');
        const visible = iaConfigPanel.classList.contains('active');
        iaConfigPanel.setAttribute('aria-hidden', visible ? 'false' : 'true');
        emitToHost('hub1.dual.settingsToggled', { open: visible });
      });
      closeIaConfigPanelBtn.addEventListener('click', () => {
        iaConfigPanel.classList.remove('active');
        iaConfigPanel.setAttribute('aria-hidden','true');
      });

      if (saveIaConfigBtn) saveIaConfigBtn.addEventListener('click', saveIaConfig);
      if (clearIaConfigBtn) clearIaConfigBtn.addEventListener('click', clearIaConfig);

      // ===== Visual viewport keyboard adjustments =====
      function adjustForViewportKeyboard(){
        if (!moduleRoot) return;
        if (!window.visualViewport) return;
        const baseBottom = 69;
        function recalc(){
          const inset = Math.max(0, Math.round(window.innerHeight - window.visualViewport.height));
          try{
            moduleRoot.style.bottom = `calc(${baseBottom}px + ${inset}px + env(safe-area-inset-bottom))`;
          }catch(e){
            moduleRoot.style.bottom = (baseBottom + inset) + 'px';
          }
        }
        window.visualViewport.addEventListener('resize', recalc);
        window.visualViewport.addEventListener('scroll', recalc);
        recalc();
      }

      // ===== Messaging from host =====
      window.addEventListener('message', (ev) => {
        const data = ev.data || {};
        if (!data || data.source !== 'hub1.host') return;
        const { type, payload } = data || {};
        if (type === 'hub1.dual.setToken'){
          if (payload && payload.token){
            CONFIG.AUTH_TOKEN = 'Bearer ' + payload.token;
            try { localStorage.setItem(STORAGE.OPENROUTER_KEY, payload.token); }catch(e){}
            loadIaConfig();
          }
        }
        if (type === 'hub1.dual.restore'){
          if (payload && Array.isArray(payload.pages)){
            renderPagesFromData(payload.pages);
          }
        }
        if (type === 'hub1.dual.setModel'){
          if (payload && payload.model){
            CONFIG.MODEL = payload.model;
            try { localStorage.setItem(STORAGE.OPENROUTER_MODEL, payload.model); }catch(e){}
            loadIaConfig();
          }
        }
      }, false);

      function init(){
        if (didInit) return;
        didInit = true;
        loadIaConfig();
        updatePageIndicator();
        setCollapsed(false);
        setupVoiceBtn();
        adjustForViewportKeyboard();
        // expose simple API
        window.Hub1DualInfodose = {
          sendText: async (txt) => {
            userInput.value = txt;
            await handleSend();
          },
          setToken: (token) => {
            CONFIG.AUTH_TOKEN = 'Bearer ' + token;
            try { localStorage.setItem(STORAGE.OPENROUTER_KEY, token); }catch(e){}
            loadIaConfig();
          },
          restorePages: (pages) => {
            renderPagesFromData(pages);
          }
        };
      }

      document.addEventListener('DOMContentLoaded', init);
      if (document.readyState === 'complete' || document.readyState === 'interactive'){
        init();
      }
    })();
  </script></body></html>